\doxysection{\+\_\+pytest.\+capture Namespace Reference}
\hypertarget{namespace__pytest_1_1capture}{}\label{namespace__pytest_1_1capture}\index{\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_base}{Capture\+Base}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_i_o}{Capture\+IO}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_manager}{Capture\+Manager}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_result}{Capture\+Result}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_dont_read_from_input}{Dont\+Read\+From\+Input}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_encoded_file}{Encoded\+File}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_f_d_capture}{FDCapture}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_f_d_capture_base}{FDCapture\+Base}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_f_d_capture_binary}{FDCapture\+Binary}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_multi_capture}{Multi\+Capture}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_no_capture}{No\+Capture}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_sys_capture}{Sys\+Capture}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_sys_capture_base}{Sys\+Capture\+Base}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_sys_capture_binary}{Sys\+Capture\+Binary}}
\item 
class \mbox{\hyperlink{class__pytest_1_1capture_1_1_tee_capture_i_o}{Tee\+Capture\+IO}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
None \mbox{\hyperlink{namespace__pytest_1_1capture_a72aac3196c562f38fe639fead1e5ae2e}{pytest\+\_\+addoption}} (\mbox{\hyperlink{class__pytest_1_1config_1_1argparsing_1_1_parser}{Parser}} parser)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1capture_aa523ebcaf82034a666e3ac3b77e466f5}{\+\_\+colorama\+\_\+workaround}} ()
\item 
None \mbox{\hyperlink{namespace__pytest_1_1capture_af46d615d81bfbf8c7f347743f323b7c5}{\+\_\+readline\+\_\+workaround}} ()
\item 
None \mbox{\hyperlink{namespace__pytest_1_1capture_a774bf124147b31b45d9b37003d172b87}{\+\_\+windowsconsoleio\+\_\+workaround}} (Text\+IO stream)
\item 
Generator\mbox{[}None\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1capture_aa262209c1997738ecd2d1499c23d9a56}{pytest\+\_\+load\+\_\+initial\+\_\+conftests}} (\mbox{\hyperlink{class__pytest_1_1config_1_1_config}{Config}} early\+\_\+config)
\item 
\mbox{\hyperlink{class__pytest_1_1capture_1_1_multi_capture}{Multi\+Capture}}\mbox{[}str\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1capture_afc655a3769cf213bf49bbbee81f98d0d}{\+\_\+get\+\_\+multicapture}} (\mbox{\hyperlink{namespace__pytest_1_1capture_a23c523da644655e1d3c38a992556ecbf}{\+\_\+\+Capture\+Method}} method)
\item 
Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}str\mbox{]}\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1capture_a7499e372d6e9da9f7ae024f029baa361}{capsys}} (\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}} request)
\item 
Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}str\mbox{]}\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1capture_af673762fc8b03e9806555db6ec487778}{capteesys}} (\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}} request)
\item 
Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}bytes\mbox{]}\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1capture_a6c049afba976711ebfb9ac5790cd602e}{capsysbinary}} (\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}} request)
\item 
Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}str\mbox{]}\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1capture_ad9af722f065b398f1edd2b2380f6de5e}{capfd}} (\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}} request)
\item 
Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}bytes\mbox{]}\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1capture_a2a436b8b98e2ace225ac986be5cd8de8}{capfdbinary}} (\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}} request)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespace__pytest_1_1capture_a23c523da644655e1d3c38a992556ecbf}{\+\_\+\+Capture\+Method}} = Literal\mbox{[}"{}fd"{}, "{}sys"{}, "{}no"{}, "{}tee-\/sys"{}\mbox{]}
\item 
dict \mbox{\hyperlink{namespace__pytest_1_1capture_a939c3c698269e398080cdedea1cb1c19}{patchsysdict}} = \{0\+: "{}stdin"{}, 1\+: "{}stdout"{}, 2\+: "{}stderr"{}\}
\item 
tuple \mbox{\hyperlink{namespace__pytest_1_1capture_a58fc7ca097ab1c3fa02e935aa1356aa4}{\+\_\+\+\_\+slots\+\_\+\+\_\+}} = ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Per-test stdout/stderr capturing mechanism.\end{DoxyVerb}
 

\label{doc-func-members}
\Hypertarget{namespace__pytest_1_1capture_doc-func-members}
\doxysubsection{Function Documentation}
\Hypertarget{namespace__pytest_1_1capture_aa523ebcaf82034a666e3ac3b77e466f5}\index{\_pytest.capture@{\_pytest.capture}!\_colorama\_workaround@{\_colorama\_workaround}}
\index{\_colorama\_workaround@{\_colorama\_workaround}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{\_colorama\_workaround()}{\_colorama\_workaround()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_aa523ebcaf82034a666e3ac3b77e466f5} 
 None \+\_\+pytest.\+capture.\+\_\+colorama\+\_\+workaround (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Ensure colorama is imported so that it attaches to the correct stdio
handles on Windows.

colorama uses the terminal on import time. So if something does the
first import of colorama while I/O capture is active, colorama will
fail in various ways.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_afc655a3769cf213bf49bbbee81f98d0d}\index{\_pytest.capture@{\_pytest.capture}!\_get\_multicapture@{\_get\_multicapture}}
\index{\_get\_multicapture@{\_get\_multicapture}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{\_get\_multicapture()}{\_get\_multicapture()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_afc655a3769cf213bf49bbbee81f98d0d} 
 \mbox{\hyperlink{class__pytest_1_1capture_1_1_multi_capture}{Multi\+Capture}}\mbox{[}str\mbox{]} \+\_\+pytest.\+capture.\+\_\+get\+\_\+multicapture (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace__pytest_1_1capture_a23c523da644655e1d3c38a992556ecbf}{\+\_\+\+Capture\+Method}}}]{method}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespace__pytest_1_1capture_af46d615d81bfbf8c7f347743f323b7c5}\index{\_pytest.capture@{\_pytest.capture}!\_readline\_workaround@{\_readline\_workaround}}
\index{\_readline\_workaround@{\_readline\_workaround}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{\_readline\_workaround()}{\_readline\_workaround()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_af46d615d81bfbf8c7f347743f323b7c5} 
 None \+\_\+pytest.\+capture.\+\_\+readline\+\_\+workaround (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Ensure readline is imported early so it attaches to the correct stdio handles.

This isn't a problem with the default GNU readline implementation, but in
some configurations, Python uses libedit instead (on macOS, and for prebuilt
binaries such as used by uv).

In theory this is only needed if readline.backend == "libedit", but the
workaround consists of importing readline here, so we already worked around
the issue by the time we could check if we need to.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_a774bf124147b31b45d9b37003d172b87}\index{\_pytest.capture@{\_pytest.capture}!\_windowsconsoleio\_workaround@{\_windowsconsoleio\_workaround}}
\index{\_windowsconsoleio\_workaround@{\_windowsconsoleio\_workaround}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{\_windowsconsoleio\_workaround()}{\_windowsconsoleio\_workaround()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_a774bf124147b31b45d9b37003d172b87} 
 None \+\_\+pytest.\+capture.\+\_\+windowsconsoleio\+\_\+workaround (\begin{DoxyParamCaption}\item[{Text\+IO}]{stream}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Workaround for Windows Unicode console handling.

Python 3.6 implemented Unicode console handling for Windows. This works
by reading/writing to the raw console handle using
``{Read,Write}ConsoleW``.

The problem is that we are going to ``dup2`` over the stdio file
descriptors when doing ``FDCapture`` and this will ``CloseHandle`` the
handles used by Python to write to the console. Though there is still some
weirdness and the console handle seems to only be closed randomly and not
on the first call to ``CloseHandle``, or maybe it gets reopened with the
same handle value when we suspend capturing.

The workaround in this case will reopen stdio with a different fd which
also means a different handle by replicating the logic in
"Py_lifecycle.c:initstdio/create_stdio".

:param stream:
    In practice ``sys.stdout`` or ``sys.stderr``, but given
    here as parameter for unittesting purposes.

See https://github.com/pytest-dev/py/issues/103.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_ad9af722f065b398f1edd2b2380f6de5e}\index{\_pytest.capture@{\_pytest.capture}!capfd@{capfd}}
\index{capfd@{capfd}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{capfd()}{capfd()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_ad9af722f065b398f1edd2b2380f6de5e} 
 Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}str\mbox{]}\mbox{]} \+\_\+pytest.\+capture.\+capfd (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}}}]{request}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Enable text capturing of writes to file descriptors ``1`` and ``2``.

The captured output is made available via ``capfd.readouterr()`` method
calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``text`` objects.

Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.

Example:

.. code-block:: python

    def test_system_echo(capfd):
        os.system('echo "hello"')
        captured = capfd.readouterr()
        assert captured.out == "hello\n"
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_a2a436b8b98e2ace225ac986be5cd8de8}\index{\_pytest.capture@{\_pytest.capture}!capfdbinary@{capfdbinary}}
\index{capfdbinary@{capfdbinary}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{capfdbinary()}{capfdbinary()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_a2a436b8b98e2ace225ac986be5cd8de8} 
 Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}bytes\mbox{]}\mbox{]} \+\_\+pytest.\+capture.\+capfdbinary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}}}]{request}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Enable bytes capturing of writes to file descriptors ``1`` and ``2``.

The captured output is made available via ``capfd.readouterr()`` method
calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``byte`` objects.

Returns an instance of :class:`CaptureFixture[bytes] <pytest.CaptureFixture>`.

Example:

.. code-block:: python

    def test_system_echo(capfdbinary):
        os.system('echo "hello"')
        captured = capfdbinary.readouterr()
        assert captured.out == b"hello\n"
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_a7499e372d6e9da9f7ae024f029baa361}\index{\_pytest.capture@{\_pytest.capture}!capsys@{capsys}}
\index{capsys@{capsys}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{capsys()}{capsys()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_a7499e372d6e9da9f7ae024f029baa361} 
 Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}str\mbox{]}\mbox{]} \+\_\+pytest.\+capture.\+capsys (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}}}]{request}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Enable text capturing of writes to ``sys.stdout`` and ``sys.stderr``.

The captured output is made available via ``capsys.readouterr()`` method
calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``text`` objects.

Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.

Example:

.. code-block:: python

def test_output(capsys):
print("hello")
captured = capsys.readouterr()
assert captured.out == "hello\n"
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_a6c049afba976711ebfb9ac5790cd602e}\index{\_pytest.capture@{\_pytest.capture}!capsysbinary@{capsysbinary}}
\index{capsysbinary@{capsysbinary}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{capsysbinary()}{capsysbinary()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_a6c049afba976711ebfb9ac5790cd602e} 
 Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}bytes\mbox{]}\mbox{]} \+\_\+pytest.\+capture.\+capsysbinary (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}}}]{request}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Enable bytes capturing of writes to ``sys.stdout`` and ``sys.stderr``.

The captured output is made available via ``capsysbinary.readouterr()``
method calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``bytes`` objects.

Returns an instance of :class:`CaptureFixture[bytes] <pytest.CaptureFixture>`.

Example:

.. code-block:: python

    def test_output(capsysbinary):
        print("hello")
        captured = capsysbinary.readouterr()
        assert captured.out == b"hello\n"
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_af673762fc8b03e9806555db6ec487778}\index{\_pytest.capture@{\_pytest.capture}!capteesys@{capteesys}}
\index{capteesys@{capteesys}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{capteesys()}{capteesys()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_af673762fc8b03e9806555db6ec487778} 
 Generator\mbox{[}\mbox{\hyperlink{class__pytest_1_1capture_1_1_capture_fixture}{Capture\+Fixture}}\mbox{[}str\mbox{]}\mbox{]} \+\_\+pytest.\+capture.\+capteesys (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class__pytest_1_1fixtures_1_1_sub_request}{Sub\+Request}}}]{request}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Enable simultaneous text capturing and pass-through of writes
to ``sys.stdout`` and ``sys.stderr`` as defined by ``--capture=``.


The captured output is made available via ``capteesys.readouterr()`` method
calls, which return a ``(out, err)`` namedtuple.
``out`` and ``err`` will be ``text`` objects.

The output is also passed-through, allowing it to be "live-printed",
reported, or both as defined by ``--capture=``.

Returns an instance of :class:`CaptureFixture[str] <pytest.CaptureFixture>`.

Example:

.. code-block:: python

def test_output(capteesys):
print("hello")
captured = capteesys.readouterr()
assert captured.out == "hello\n"
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_a72aac3196c562f38fe639fead1e5ae2e}\index{\_pytest.capture@{\_pytest.capture}!pytest\_addoption@{pytest\_addoption}}
\index{pytest\_addoption@{pytest\_addoption}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{pytest\_addoption()}{pytest\_addoption()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_a72aac3196c562f38fe639fead1e5ae2e} 
 None \+\_\+pytest.\+capture.\+pytest\+\_\+addoption (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class__pytest_1_1config_1_1argparsing_1_1_parser}{Parser}}}]{parser}{}\end{DoxyParamCaption})}

\Hypertarget{namespace__pytest_1_1capture_aa262209c1997738ecd2d1499c23d9a56}\index{\_pytest.capture@{\_pytest.capture}!pytest\_load\_initial\_conftests@{pytest\_load\_initial\_conftests}}
\index{pytest\_load\_initial\_conftests@{pytest\_load\_initial\_conftests}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{pytest\_load\_initial\_conftests()}{pytest\_load\_initial\_conftests()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_aa262209c1997738ecd2d1499c23d9a56} 
 Generator\mbox{[}None\mbox{]} \+\_\+pytest.\+capture.\+pytest\+\_\+load\+\_\+initial\+\_\+conftests (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class__pytest_1_1config_1_1_config}{Config}}}]{early\+\_\+config}{}\end{DoxyParamCaption})}



\label{doc-var-members}
\Hypertarget{namespace__pytest_1_1capture_doc-var-members}
\doxysubsection{Variable Documentation}
\Hypertarget{namespace__pytest_1_1capture_a58fc7ca097ab1c3fa02e935aa1356aa4}\index{\_pytest.capture@{\_pytest.capture}!\_\_slots\_\_@{\_\_slots\_\_}}
\index{\_\_slots\_\_@{\_\_slots\_\_}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{\_\_slots\_\_}{\_\_slots\_\_}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_a58fc7ca097ab1c3fa02e935aa1356aa4} 
tuple \+\_\+pytest.\+capture.\+\_\+\+\_\+slots\+\_\+\+\_\+ = ()\hspace{0.3cm}{\ttfamily [private]}}

\begin{DoxyVerb}The result of :method:`caplog.readouterr() <pytest.CaptureFixture.readouterr>`.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1capture_a23c523da644655e1d3c38a992556ecbf}\index{\_pytest.capture@{\_pytest.capture}!\_CaptureMethod@{\_CaptureMethod}}
\index{\_CaptureMethod@{\_CaptureMethod}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{\_CaptureMethod}{\_CaptureMethod}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_a23c523da644655e1d3c38a992556ecbf} 
\+\_\+pytest.\+capture.\+\_\+\+Capture\+Method = Literal\mbox{[}"{}fd"{}, "{}sys"{}, "{}no"{}, "{}tee-\/sys"{}\mbox{]}\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespace__pytest_1_1capture_a939c3c698269e398080cdedea1cb1c19}\index{\_pytest.capture@{\_pytest.capture}!patchsysdict@{patchsysdict}}
\index{patchsysdict@{patchsysdict}!\_pytest.capture@{\_pytest.capture}}
\doxysubsubsection{\texorpdfstring{patchsysdict}{patchsysdict}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1capture_a939c3c698269e398080cdedea1cb1c19} 
dict \+\_\+pytest.\+capture.\+patchsysdict = \{0\+: "{}stdin"{}, 1\+: "{}stdout"{}, 2\+: "{}stderr"{}\}}

