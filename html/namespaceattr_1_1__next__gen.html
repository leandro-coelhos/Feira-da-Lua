<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: attr._next_gen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceattr_1_1__next__gen.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">attr._next_gen Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae959bdd0a03198331a782e9a6754fc05" id="r_ae959bdd0a03198331a782e9a6754fc05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae959bdd0a03198331a782e9a6754fc05">define</a> (maybe_cls=None, *, these=None, repr=None, unsafe_hash=None, hash=None, init=None, slots=True, <a class="el" href="#a77c0efd853025e306c7e59f799e9818b">frozen</a>=False, weakref_slot=True, str=False, auto_attribs=None, kw_only=False, cache_hash=False, auto_exc=True, eq=None, order=False, auto_detect=True, getstate_setstate=None, on_setattr=None, field_transformer=None, match_args=True, force_kw_only=False)</td></tr>
<tr class="memitem:a06daa74ff11dc507375ca15baa3c8a39" id="r_a06daa74ff11dc507375ca15baa3c8a39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06daa74ff11dc507375ca15baa3c8a39">field</a> (*, default=NOTHING, validator=None, repr=True, hash=None, init=True, metadata=None, type=None, converter=None, factory=None, kw_only=None, eq=None, order=None, on_setattr=None, alias=None)</td></tr>
<tr class="memitem:a4ebf51224d74e9f032212b9985338621" id="r_a4ebf51224d74e9f032212b9985338621"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ebf51224d74e9f032212b9985338621">asdict</a> (inst, *, recurse=True, filter=None, value_serializer=None)</td></tr>
<tr class="memitem:acf915be8a843dbc3b44524de5a30f164" id="r_acf915be8a843dbc3b44524de5a30f164"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf915be8a843dbc3b44524de5a30f164">astuple</a> (inst, *, recurse=True, filter=None)</td></tr>
<tr class="memitem:a36ed63b2b7b3dac88074ec40e670d547" id="r_a36ed63b2b7b3dac88074ec40e670d547"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36ed63b2b7b3dac88074ec40e670d547">inspect</a> (cls)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a876fb926bd6bb368cb941662919a2fd5" id="r_a876fb926bd6bb368cb941662919a2fd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a876fb926bd6bb368cb941662919a2fd5">mutable</a> = <a class="el" href="#ae959bdd0a03198331a782e9a6754fc05">define</a></td></tr>
<tr class="memitem:a77c0efd853025e306c7e59f799e9818b" id="r_a77c0efd853025e306c7e59f799e9818b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77c0efd853025e306c7e59f799e9818b">frozen</a> = partial(<a class="el" href="#ae959bdd0a03198331a782e9a6754fc05">define</a>, frozen=True, on_setattr=None)</td></tr>
<tr class="memitem:aaf2e89ba009ea06198dcf31b22b24ffe" id="r_aaf2e89ba009ea06198dcf31b22b24ffe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf2e89ba009ea06198dcf31b22b24ffe">__bases__</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">These are keyword-only APIs that call `attr.s` and `attr.ib` with different
default values.
</pre> </div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a4ebf51224d74e9f032212b9985338621" name="a4ebf51224d74e9f032212b9985338621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebf51224d74e9f032212b9985338621">&#9670;&#160;</a></span>asdict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.asdict </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>recurse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>value_serializer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Same as `attr.asdict`, except that collections types are always retained
and dict is always used as *dict_factory*.

.. versionadded:: 21.3.0
</pre> 
</div>
</div>
<a id="acf915be8a843dbc3b44524de5a30f164" name="acf915be8a843dbc3b44524de5a30f164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf915be8a843dbc3b44524de5a30f164">&#9670;&#160;</a></span>astuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.astuple </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>recurse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Same as `attr.astuple`, except that collections types are always retained
and `tuple` is always used as the *tuple_factory*.

.. versionadded:: 21.3.0
</pre> 
</div>
</div>
<a id="ae959bdd0a03198331a782e9a6754fc05" name="ae959bdd0a03198331a782e9a6754fc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae959bdd0a03198331a782e9a6754fc05">&#9670;&#160;</a></span>define()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.define </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>maybe_cls</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>these</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>repr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>unsafe_hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>init</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>slots</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>frozen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>weakref_slot</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>str</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>auto_attribs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>kw_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cache_hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>auto_exc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>eq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>auto_detect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>getstate_setstate</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>on_setattr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>field_transformer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>match_args</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>force_kw_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A class decorator that adds :term:`dunder methods` according to
:term:`fields &lt;field&gt;` specified using :doc:`type annotations &lt;types&gt;`,
`field()` calls, or the *these* argument.

Since *attrs* patches or replaces an existing class, you cannot use
`object.__init_subclass__` with *attrs* classes, because it runs too early.
As a replacement, you can define ``__attrs_init_subclass__`` on your class.
It will be called by *attrs* classes that subclass it after they're
created. See also :ref:`init-subclass`.

Args:
    slots (bool):
        Create a :term:`slotted class &lt;slotted classes&gt;` that's more
        memory-efficient. Slotted classes are generally superior to the
        default dict classes, but have some gotchas you should know about,
        so we encourage you to read the :term:`glossary entry &lt;slotted
        classes&gt;`.

    auto_detect (bool):
        Instead of setting the *init*, *repr*, *eq*, and *hash* arguments
        explicitly, assume they are set to True **unless any** of the
        involved methods for one of the arguments is implemented in the
        *current* class (meaning, it is *not* inherited from some base
        class).

        So, for example by implementing ``__eq__`` on a class yourself,
        *attrs* will deduce ``eq=False`` and will create *neither*
        ``__eq__`` *nor* ``__ne__`` (but Python classes come with a
        sensible ``__ne__`` by default, so it *should* be enough to only
        implement ``__eq__`` in most cases).

        Passing :data:`True` or :data:`False` to *init*, *repr*, *eq*, or *hash*
        overrides whatever *auto_detect* would determine.

    auto_exc (bool):
        If the class subclasses `BaseException` (which implicitly includes
        any subclass of any exception), the following happens to behave
        like a well-behaved Python exception class:

        - the values for *eq*, *order*, and *hash* are ignored and the
          instances compare and hash by the instance's ids [#]_ ,
        - all attributes that are either passed into ``__init__`` or have a
          default value are additionally available as a tuple in the
          ``args`` attribute,
        - the value of *str* is ignored leaving ``__str__`` to base
          classes.

        .. [#]
           Note that *attrs* will *not* remove existing implementations of
           ``__hash__`` or the equality methods. It just won't add own
           ones.

    on_setattr (~typing.Callable | list[~typing.Callable] | None | ~typing.Literal[attrs.setters.NO_OP]):
        A callable that is run whenever the user attempts to set an
        attribute (either by assignment like ``i.x = 42`` or by using
        `setattr` like ``setattr(i, "x", 42)``). It receives the same
        arguments as validators: the instance, the attribute that is being
        modified, and the new value.

        If no exception is raised, the attribute is set to the return value
        of the callable.

        If a list of callables is passed, they're automatically wrapped in
        an `attrs.setters.pipe`.

        If left None, the default behavior is to run converters and
        validators whenever an attribute is set.

    init (bool):
        Create a ``__init__`` method that initializes the *attrs*
        attributes. Leading underscores are stripped for the argument name,
        unless an alias is set on the attribute.

        .. seealso::
            `init` shows advanced ways to customize the generated
            ``__init__`` method, including executing code before and after.

    repr(bool):
        Create a ``__repr__`` method with a human readable representation
        of *attrs* attributes.

    str (bool):
        Create a ``__str__`` method that is identical to ``__repr__``. This
        is usually not necessary except for `Exception`\ s.

    eq (bool | None):
        If True or None (default), add ``__eq__`` and ``__ne__`` methods
        that check two instances for equality.

        .. seealso::
            `comparison` describes how to customize the comparison behavior
            going as far comparing NumPy arrays.

    order (bool | None):
        If True, add ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__``
        methods that behave like *eq* above and allow instances to be
        ordered.

        They compare the instances as if they were tuples of their *attrs*
        attributes if and only if the types of both classes are
        *identical*.

        If `None` mirror value of *eq*.

        .. seealso:: `comparison`

    unsafe_hash (bool | None):
        If None (default), the ``__hash__`` method is generated according
        how *eq* and *frozen* are set.

        1. If *both* are True, *attrs* will generate a ``__hash__`` for
           you.
        2. If *eq* is True and *frozen* is False, ``__hash__`` will be set
           to None, marking it unhashable (which it is).
        3. If *eq* is False, ``__hash__`` will be left untouched meaning
           the ``__hash__`` method of the base class will be used. If the
           base class is `object`, this means it will fall back to id-based
           hashing.

        Although not recommended, you can decide for yourself and force
        *attrs* to create one (for example, if the class is immutable even
        though you didn't freeze it programmatically) by passing True or
        not.  Both of these cases are rather special and should be used
        carefully.

        .. seealso::

            - Our documentation on `hashing`,
            - Python's documentation on `object.__hash__`,
            - and the `GitHub issue that led to the default \ behavior
              &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more
              details.

    hash (bool | None):
        Deprecated alias for *unsafe_hash*. *unsafe_hash* takes precedence.

    cache_hash (bool):
        Ensure that the object's hash code is computed only once and stored
        on the object.  If this is set to True, hashing must be either
        explicitly or implicitly enabled for this class.  If the hash code
        is cached, avoid any reassignments of fields involved in hash code
        computation or mutations of the objects those fields point to after
        object creation.  If such changes occur, the behavior of the
        object's hash code is undefined.

    frozen (bool):
        Make instances immutable after initialization.  If someone attempts
        to modify a frozen instance, `attrs.exceptions.FrozenInstanceError`
        is raised.

        .. note::

            1. This is achieved by installing a custom ``__setattr__``
               method on your class, so you can't implement your own.

            2. True immutability is impossible in Python.

            3. This *does* have a minor a runtime performance `impact
               &lt;how-frozen&gt;` when initializing new instances.  In other
               words: ``__init__`` is slightly slower with ``frozen=True``.

            4. If a class is frozen, you cannot modify ``self`` in
               ``__attrs_post_init__`` or a self-written ``__init__``. You
               can circumvent that limitation by using
               ``object.__setattr__(self, "attribute_name", value)``.

            5. Subclasses of a frozen class are frozen too.

    kw_only (bool):
        Make attributes keyword-only in the generated ``__init__`` (if
        *init* is False, this parameter is ignored).  Attributes that
        explicitly set ``kw_only=False`` are not affected; base class
        attributes are also not affected.

        Also see *force_kw_only*.

    weakref_slot (bool):
        Make instances weak-referenceable.  This has no effect unless
        *slots* is True.

    field_transformer (~typing.Callable | None):
        A function that is called with the original class object and all
        fields right before *attrs* finalizes the class.  You can use this,
        for example, to automatically add converters or validators to
        fields based on their types.

        .. seealso:: `transform-fields`

    match_args (bool):
        If True (default), set ``__match_args__`` on the class to support
        :pep:`634` (*Structural Pattern Matching*). It is a tuple of all
        non-keyword-only ``__init__`` parameter names on Python 3.10 and
        later. Ignored on older Python versions.

    collect_by_mro (bool):
        If True, *attrs* collects attributes from base classes correctly
        according to the `method resolution order
        &lt;https://docs.python.org/3/howto/mro.html&gt;`_. If False, *attrs*
        will mimic the (wrong) behavior of `dataclasses` and :pep:`681`.

        See also `issue #428
        &lt;https://github.com/python-attrs/attrs/issues/428&gt;`_.

    force_kw_only (bool):
        A back-compat flag for restoring pre-25.4.0 behavior.  If True and
        ``kw_only=True``, all attributes are made keyword-only, including
        base class attributes, and those set to ``kw_only=False`` at the
        attribute level.  Defaults to False.

        See also `issue #980
        &lt;https://github.com/python-attrs/attrs/issues/980&gt;`_.

    getstate_setstate (bool | None):
        .. note::

            This is usually only interesting for slotted classes and you
            should probably just set *auto_detect* to True.

        If True, ``__getstate__`` and ``__setstate__`` are generated and
        attached to the class. This is necessary for slotted classes to be
        pickleable. If left None, it's True by default for slotted classes
        and False for dict classes.

        If *auto_detect* is True, and *getstate_setstate* is left None, and
        **either** ``__getstate__`` or ``__setstate__`` is detected
        directly on the class (meaning: not inherited), it is set to False
        (this is usually what you want).

    auto_attribs (bool | None):
        If True, look at type annotations to determine which attributes to
        use, like `dataclasses`. If False, it will only look for explicit
        :func:`field` class attributes, like classic *attrs*.

        If left None, it will guess:

        1. If any attributes are annotated and no unannotated
           `attrs.field`\ s are found, it assumes *auto_attribs=True*.
        2. Otherwise it assumes *auto_attribs=False* and tries to collect
           `attrs.field`\ s.

        If *attrs* decides to look at type annotations, **all** fields
        **must** be annotated. If *attrs* encounters a field that is set to
        a :func:`field` / `attr.ib` but lacks a type annotation, an
        `attrs.exceptions.UnannotatedAttributeError` is raised.  Use
        ``field_name: typing.Any = field(...)`` if you don't want to set a
        type.

        .. warning::

            For features that use the attribute name to create decorators
            (for example, :ref:`validators &lt;validators&gt;`), you still *must*
            assign :func:`field` / `attr.ib` to them. Otherwise Python will
            either not find the name or try to use the default value to
            call, for example, ``validator`` on it.

        Attributes annotated as `typing.ClassVar`, and attributes that are
        neither annotated nor set to an `field()` are **ignored**.

    these (dict[str, object]):
        A dictionary of name to the (private) return value of `field()`
        mappings. This is useful to avoid the definition of your attributes
        within the class body because you can't (for example, if you want
        to add ``__repr__`` methods to Django models) or don't want to.

        If *these* is not `None`, *attrs* will *not* search the class body
        for attributes and will *not* remove any attributes from it.

        The order is deduced from the order of the attributes inside
        *these*.

        Arguably, this is a rather obscure feature.

.. versionadded:: 20.1.0
.. versionchanged:: 21.3.0 Converters are also run ``on_setattr``.
.. versionadded:: 22.2.0
   *unsafe_hash* as an alias for *hash* (for :pep:`681` compliance).
.. versionchanged:: 24.1.0
   Instances are not compared as tuples of attributes anymore, but using a
   big ``and`` condition. This is faster and has more correct behavior for
   uncomparable values like `math.nan`.
.. versionadded:: 24.1.0
   If a class has an *inherited* classmethod called
   ``__attrs_init_subclass__``, it is executed after the class is created.
.. deprecated:: 24.1.0 *hash* is deprecated in favor of *unsafe_hash*.
.. versionadded:: 24.3.0
   Unless already present, a ``__replace__`` method is automatically
   created for `copy.replace` (Python 3.13+ only).
.. versionchanged:: 25.4.0
   *kw_only* now only applies to attributes defined in the current class,
   and respects attribute-level ``kw_only=False`` settings.
.. versionadded:: 25.4.0
   Added *force_kw_only* to go back to the previous *kw_only* behavior.

.. note::

    The main differences to the classic `attr.s` are:

    - Automatically detect whether or not *auto_attribs* should be `True`
      (c.f. *auto_attribs* parameter).
    - Converters and validators run when attributes are set by default --
      if *frozen* is `False`.
    - *slots=True*

      Usually, this has only upsides and few visible effects in everyday
      programming. But it *can* lead to some surprising behaviors, so
      please make sure to read :term:`slotted classes`.

    - *auto_exc=True*
    - *auto_detect=True*
    - *order=False*
    - *force_kw_only=False*
    - Some options that were only relevant on Python 2 or were kept around
      for backwards-compatibility have been removed.
</pre> 
</div>
</div>
<a id="a06daa74ff11dc507375ca15baa3c8a39" name="a06daa74ff11dc507375ca15baa3c8a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06daa74ff11dc507375ca15baa3c8a39">&#9670;&#160;</a></span>field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.field </td>
          <td>(</td>
          <td class="paramtype">*</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>default</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NOTHING</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>validator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>repr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>hash</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>init</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>metadata</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>converter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>factory</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>kw_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>eq</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>order</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>on_setattr</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>alias</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a new :term:`field` / :term:`attribute` on a class.

..  warning::

    Does **nothing** unless the class is also decorated with
    `attrs.define` (or similar)!

Args:
    default:
        A value that is used if an *attrs*-generated ``__init__`` is used
        and no value is passed while instantiating or the attribute is
        excluded using ``init=False``.

        If the value is an instance of `attrs.Factory`, its callable will
        be used to construct a new value (useful for mutable data types
        like lists or dicts).

        If a default is not set (or set manually to `attrs.NOTHING`), a
        value *must* be supplied when instantiating; otherwise a
        `TypeError` will be raised.

        .. seealso:: `defaults`

    factory (~typing.Callable):
        Syntactic sugar for ``default=attr.Factory(factory)``.

    validator (~typing.Callable | list[~typing.Callable]):
        Callable that is called by *attrs*-generated ``__init__`` methods
        after the instance has been initialized.  They receive the
        initialized instance, the :func:`~attrs.Attribute`, and the passed
        value.

        The return value is *not* inspected so the validator has to throw
        an exception itself.

        If a `list` is passed, its items are treated as validators and must
        all pass.

        Validators can be globally disabled and re-enabled using
        `attrs.validators.get_disabled` / `attrs.validators.set_disabled`.

        The validator can also be set using decorator notation as shown
        below.

        .. seealso:: :ref:`validators`

    repr (bool | ~typing.Callable):
        Include this attribute in the generated ``__repr__`` method. If
        True, include the attribute; if False, omit it. By default, the
        built-in ``repr()`` function is used. To override how the attribute
        value is formatted, pass a ``callable`` that takes a single value
        and returns a string. Note that the resulting string is used as-is,
        which means it will be used directly *instead* of calling
        ``repr()`` (the default).

    eq (bool | ~typing.Callable):
        If True (default), include this attribute in the generated
        ``__eq__`` and ``__ne__`` methods that check two instances for
        equality. To override how the attribute value is compared, pass a
        callable that takes a single value and returns the value to be
        compared.

        .. seealso:: `comparison`

    order (bool | ~typing.Callable):
        If True (default), include this attributes in the generated
        ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods. To
        override how the attribute value is ordered, pass a callable that
        takes a single value and returns the value to be ordered.

        .. seealso:: `comparison`

    hash (bool | None):
        Include this attribute in the generated ``__hash__`` method.  If
        None (default), mirror *eq*'s value.  This is the correct behavior
        according the Python spec.  Setting this value to anything else
        than None is *discouraged*.

        .. seealso:: `hashing`

    init (bool):
        Include this attribute in the generated ``__init__`` method.

        It is possible to set this to False and set a default value. In
        that case this attributed is unconditionally initialized with the
        specified default value or factory.

        .. seealso:: `init`

    converter (typing.Callable | Converter):
        A callable that is called by *attrs*-generated ``__init__`` methods
        to convert attribute's value to the desired format.

        If a vanilla callable is passed, it is given the passed-in value as
        the only positional argument. It is possible to receive additional
        arguments by wrapping the callable in a `Converter`.

        Either way, the returned value will be used as the new value of the
        attribute.  The value is converted before being passed to the
        validator, if any.

        .. seealso:: :ref:`converters`

    metadata (dict | None):
        An arbitrary mapping, to be used by third-party code.

        .. seealso:: `extending-metadata`.

    type (type):
        The type of the attribute. Nowadays, the preferred method to
        specify the type is using a variable annotation (see :pep:`526`).
        This argument is provided for backwards-compatibility and for usage
        with `make_class`. Regardless of the approach used, the type will
        be stored on ``Attribute.type``.

        Please note that *attrs* doesn't do anything with this metadata by
        itself. You can use it as part of your own code or for `static type
        checking &lt;types&gt;`.

    kw_only (bool | None):
        Make this attribute keyword-only in the generated ``__init__`` (if
        *init* is False, this parameter is ignored).  If None (default),
        mirror the setting from `attrs.define`.

    on_setattr (~typing.Callable | list[~typing.Callable] | None | ~typing.Literal[attrs.setters.NO_OP]):
        Allows to overwrite the *on_setattr* setting from `attr.s`. If left
        None, the *on_setattr* value from `attr.s` is used. Set to
        `attrs.setters.NO_OP` to run **no** `setattr` hooks for this
        attribute -- regardless of the setting in `define()`.

    alias (str | None):
        Override this attribute's parameter name in the generated
        ``__init__`` method. If left None, default to ``name`` stripped
        of leading underscores. See `private-attributes`.

.. versionadded:: 20.1.0
.. versionchanged:: 21.1.0
   *eq*, *order*, and *cmp* also accept a custom callable
.. versionadded:: 22.2.0 *alias*
.. versionadded:: 23.1.0
   The *type* parameter has been re-added; mostly for `attrs.make_class`.
   Please note that type checkers ignore this metadata.
.. versionchanged:: 25.4.0
   *kw_only* can now be None, and its default is also changed from False to
   None.

.. seealso::

   `attr.ib`
</pre> 
</div>
</div>
<a id="a36ed63b2b7b3dac88074ec40e670d547" name="a36ed63b2b7b3dac88074ec40e670d547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ed63b2b7b3dac88074ec40e670d547">&#9670;&#160;</a></span>inspect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.inspect </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cls</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Inspect the class and return its effective build parameters.

Warning:
    This feature is currently **experimental** and is not covered by our
    strict backwards-compatibility guarantees.

Args:
    cls: The *attrs*-decorated class to inspect.

Returns:
    The effective build parameters of the class.

Raises:
    NotAnAttrsClassError: If the class is not an *attrs*-decorated class.

.. versionadded:: 25.4.0
</pre> 
</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="aaf2e89ba009ea06198dcf31b22b24ffe" name="aaf2e89ba009ea06198dcf31b22b24ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2e89ba009ea06198dcf31b22b24ffe">&#9670;&#160;</a></span>__bases__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.__bases__</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77c0efd853025e306c7e59f799e9818b" name="a77c0efd853025e306c7e59f799e9818b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c0efd853025e306c7e59f799e9818b">&#9670;&#160;</a></span>frozen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.frozen = partial(<a class="el" href="#ae959bdd0a03198331a782e9a6754fc05">define</a>, frozen=True, on_setattr=None)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a876fb926bd6bb368cb941662919a2fd5" name="a876fb926bd6bb368cb941662919a2fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876fb926bd6bb368cb941662919a2fd5">&#9670;&#160;</a></span>mutable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._next_gen.mutable = <a class="el" href="#ae959bdd0a03198331a782e9a6754fc05">define</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceattr.html">attr</a></li><li class="navelem"><a href="namespaceattr_1_1__next__gen.html">_next_gen</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
