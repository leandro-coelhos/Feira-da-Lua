\doxysection{charset\+\_\+normalizer.\+api Namespace Reference}
\hypertarget{namespacecharset__normalizer_1_1api}{}\label{namespacecharset__normalizer_1_1api}\index{charset\_normalizer.api@{charset\_normalizer.api}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classcharset__normalizer_1_1models_1_1_charset_matches}{Charset\+Matches}} \mbox{\hyperlink{namespacecharset__normalizer_1_1api_a81ef2f82c4e31150d2e531646eeaee07}{from\+\_\+bytes}} (bytes\texorpdfstring{$\vert$}{|}bytearray sequences, int steps=5, int chunk\+\_\+size=512, float threshold=0.\+2, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None cp\+\_\+isolation=None, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None cp\+\_\+exclusion=None, bool preemptive\+\_\+behaviour=True, bool explain=False, float language\+\_\+threshold=0.\+1, bool enable\+\_\+fallback=True)
\item 
\mbox{\hyperlink{classcharset__normalizer_1_1models_1_1_charset_matches}{Charset\+Matches}} \mbox{\hyperlink{namespacecharset__normalizer_1_1api_a16c5753c54249e0c69bbe25c40841f02}{from\+\_\+fp}} (Binary\+IO fp, int steps=5, int chunk\+\_\+size=512, float threshold=0.\+20, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None cp\+\_\+isolation=None, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None cp\+\_\+exclusion=None, bool preemptive\+\_\+behaviour=True, bool explain=False, float language\+\_\+threshold=0.\+1, bool enable\+\_\+fallback=True)
\item 
\mbox{\hyperlink{classcharset__normalizer_1_1models_1_1_charset_matches}{Charset\+Matches}} \mbox{\hyperlink{namespacecharset__normalizer_1_1api_af8af98f779a447256c4ef4f0bb6f9506}{from\+\_\+path}} (str\texorpdfstring{$\vert$}{|}bytes\texorpdfstring{$\vert$}{|}Path\+Like path, int steps=5, int chunk\+\_\+size=512, float threshold=0.\+20, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None cp\+\_\+isolation=None, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None cp\+\_\+exclusion=None, bool preemptive\+\_\+behaviour=True, bool explain=False, float language\+\_\+threshold=0.\+1, bool enable\+\_\+fallback=True)
\item 
bool \mbox{\hyperlink{namespacecharset__normalizer_1_1api_aac21c854d7c4f11550447e638ef2bb0c}{is\+\_\+binary}} (Path\+Like\texorpdfstring{$\vert$}{|}str\texorpdfstring{$\vert$}{|}Binary\+IO\texorpdfstring{$\vert$}{|}bytes fp\+\_\+or\+\_\+path\+\_\+or\+\_\+payload, int steps=5, int chunk\+\_\+size=512, float threshold=0.\+20, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None cp\+\_\+isolation=None, list\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}None cp\+\_\+exclusion=None, bool preemptive\+\_\+behaviour=True, bool explain=False, float language\+\_\+threshold=0.\+1, bool enable\+\_\+fallback=False)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacecharset__normalizer_1_1api_a8e36221dc81c38e9f1e3b7ba080033dd}{logger}} = logging.\+get\+Logger("{}charset\+\_\+normalizer"{})
\item 
\mbox{\hyperlink{namespacecharset__normalizer_1_1api_a44cf743eabaedb7d9e144a00180a8ebd}{explain\+\_\+handler}} = logging.\+Stream\+Handler()
\end{DoxyCompactItemize}


\label{doc-func-members}
\Hypertarget{namespacecharset__normalizer_1_1api_doc-func-members}
\doxysubsection{Function Documentation}
\Hypertarget{namespacecharset__normalizer_1_1api_a81ef2f82c4e31150d2e531646eeaee07}\index{charset\_normalizer.api@{charset\_normalizer.api}!from\_bytes@{from\_bytes}}
\index{from\_bytes@{from\_bytes}!charset\_normalizer.api@{charset\_normalizer.api}}
\doxysubsubsection{\texorpdfstring{from\_bytes()}{from\_bytes()}}
{\footnotesize\ttfamily \label{namespacecharset__normalizer_1_1api_a81ef2f82c4e31150d2e531646eeaee07} 
 \mbox{\hyperlink{classcharset__normalizer_1_1models_1_1_charset_matches}{Charset\+Matches}} charset\+\_\+normalizer.\+api.\+from\+\_\+bytes (\begin{DoxyParamCaption}\item[{bytes \texorpdfstring{$\vert$}{|} bytearray}]{sequences}{, }\item[{int }]{steps}{ = {\ttfamily 5}, }\item[{int }]{chunk\+\_\+size}{ = {\ttfamily 512}, }\item[{float }]{threshold}{ = {\ttfamily 0.2}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{cp\+\_\+isolation}{ = {\ttfamily None}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{cp\+\_\+exclusion}{ = {\ttfamily None}, }\item[{bool }]{preemptive\+\_\+behaviour}{ = {\ttfamily True}, }\item[{bool }]{explain}{ = {\ttfamily False}, }\item[{float }]{language\+\_\+threshold}{ = {\ttfamily 0.1}, }\item[{bool }]{enable\+\_\+fallback}{ = {\ttfamily True}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Given a raw bytes sequence, return the best possibles charset usable to render str objects.
If there is no results, it is a strong indicator that the source is binary/not text.
By default, the process will extract 5 blocks of 512o each to assess the mess and coherence of a given sequence.
And will give up a particular code page after 20% of measured mess. Those criteria are customizable at will.

The preemptive behavior DOES NOT replace the traditional detection workflow, it prioritize a particular code page
but never take it for granted. Can improve the performance.

You may want to focus your attention to some code page or/and not others, use cp_isolation and cp_exclusion for that
purpose.

This function will strip the SIG in the payload/sequence every time except on UTF-16, UTF-32.
By default the library does not setup any handler other than the NullHandler, if you choose to set the 'explain'
toggle to True it will alter the logger configuration to add a StreamHandler that is suitable for debugging.
Custom logging format and handler can be set manually.
\end{DoxyVerb}
 \Hypertarget{namespacecharset__normalizer_1_1api_a16c5753c54249e0c69bbe25c40841f02}\index{charset\_normalizer.api@{charset\_normalizer.api}!from\_fp@{from\_fp}}
\index{from\_fp@{from\_fp}!charset\_normalizer.api@{charset\_normalizer.api}}
\doxysubsubsection{\texorpdfstring{from\_fp()}{from\_fp()}}
{\footnotesize\ttfamily \label{namespacecharset__normalizer_1_1api_a16c5753c54249e0c69bbe25c40841f02} 
 \mbox{\hyperlink{classcharset__normalizer_1_1models_1_1_charset_matches}{Charset\+Matches}} charset\+\_\+normalizer.\+api.\+from\+\_\+fp (\begin{DoxyParamCaption}\item[{Binary\+IO}]{fp}{, }\item[{int }]{steps}{ = {\ttfamily 5}, }\item[{int }]{chunk\+\_\+size}{ = {\ttfamily 512}, }\item[{float }]{threshold}{ = {\ttfamily 0.20}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{cp\+\_\+isolation}{ = {\ttfamily None}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{cp\+\_\+exclusion}{ = {\ttfamily None}, }\item[{bool }]{preemptive\+\_\+behaviour}{ = {\ttfamily True}, }\item[{bool }]{explain}{ = {\ttfamily False}, }\item[{float }]{language\+\_\+threshold}{ = {\ttfamily 0.1}, }\item[{bool }]{enable\+\_\+fallback}{ = {\ttfamily True}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Same thing than the function from_bytes but using a file pointer that is already ready.
Will not close the file pointer.
\end{DoxyVerb}
 \Hypertarget{namespacecharset__normalizer_1_1api_af8af98f779a447256c4ef4f0bb6f9506}\index{charset\_normalizer.api@{charset\_normalizer.api}!from\_path@{from\_path}}
\index{from\_path@{from\_path}!charset\_normalizer.api@{charset\_normalizer.api}}
\doxysubsubsection{\texorpdfstring{from\_path()}{from\_path()}}
{\footnotesize\ttfamily \label{namespacecharset__normalizer_1_1api_af8af98f779a447256c4ef4f0bb6f9506} 
 \mbox{\hyperlink{classcharset__normalizer_1_1models_1_1_charset_matches}{Charset\+Matches}} charset\+\_\+normalizer.\+api.\+from\+\_\+path (\begin{DoxyParamCaption}\item[{str \texorpdfstring{$\vert$}{|} bytes \texorpdfstring{$\vert$}{|} Path\+Like}]{path}{, }\item[{int }]{steps}{ = {\ttfamily 5}, }\item[{int }]{chunk\+\_\+size}{ = {\ttfamily 512}, }\item[{float }]{threshold}{ = {\ttfamily 0.20}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{cp\+\_\+isolation}{ = {\ttfamily None}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{cp\+\_\+exclusion}{ = {\ttfamily None}, }\item[{bool }]{preemptive\+\_\+behaviour}{ = {\ttfamily True}, }\item[{bool }]{explain}{ = {\ttfamily False}, }\item[{float }]{language\+\_\+threshold}{ = {\ttfamily 0.1}, }\item[{bool }]{enable\+\_\+fallback}{ = {\ttfamily True}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Same thing than the function from_bytes but with one extra step. Opening and reading given file path in binary mode.
Can raise IOError.
\end{DoxyVerb}
 \Hypertarget{namespacecharset__normalizer_1_1api_aac21c854d7c4f11550447e638ef2bb0c}\index{charset\_normalizer.api@{charset\_normalizer.api}!is\_binary@{is\_binary}}
\index{is\_binary@{is\_binary}!charset\_normalizer.api@{charset\_normalizer.api}}
\doxysubsubsection{\texorpdfstring{is\_binary()}{is\_binary()}}
{\footnotesize\ttfamily \label{namespacecharset__normalizer_1_1api_aac21c854d7c4f11550447e638ef2bb0c} 
 bool charset\+\_\+normalizer.\+api.\+is\+\_\+binary (\begin{DoxyParamCaption}\item[{Path\+Like \texorpdfstring{$\vert$}{|} str \texorpdfstring{$\vert$}{|} Binary\+IO \texorpdfstring{$\vert$}{|} bytes}]{fp\+\_\+or\+\_\+path\+\_\+or\+\_\+payload}{, }\item[{int }]{steps}{ = {\ttfamily 5}, }\item[{int }]{chunk\+\_\+size}{ = {\ttfamily 512}, }\item[{float }]{threshold}{ = {\ttfamily 0.20}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{cp\+\_\+isolation}{ = {\ttfamily None}, }\item[{list\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} None }]{cp\+\_\+exclusion}{ = {\ttfamily None}, }\item[{bool }]{preemptive\+\_\+behaviour}{ = {\ttfamily True}, }\item[{bool }]{explain}{ = {\ttfamily False}, }\item[{float }]{language\+\_\+threshold}{ = {\ttfamily 0.1}, }\item[{bool }]{enable\+\_\+fallback}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Detect if the given input (file, bytes, or path) points to a binary file. aka. not a string.
Based on the same main heuristic algorithms and default kwargs at the sole exception that fallbacks match
are disabled to be stricter around ASCII-compatible but unlikely to be a string.
\end{DoxyVerb}
 

\label{doc-var-members}
\Hypertarget{namespacecharset__normalizer_1_1api_doc-var-members}
\doxysubsection{Variable Documentation}
\Hypertarget{namespacecharset__normalizer_1_1api_a44cf743eabaedb7d9e144a00180a8ebd}\index{charset\_normalizer.api@{charset\_normalizer.api}!explain\_handler@{explain\_handler}}
\index{explain\_handler@{explain\_handler}!charset\_normalizer.api@{charset\_normalizer.api}}
\doxysubsubsection{\texorpdfstring{explain\_handler}{explain\_handler}}
{\footnotesize\ttfamily \label{namespacecharset__normalizer_1_1api_a44cf743eabaedb7d9e144a00180a8ebd} 
charset\+\_\+normalizer.\+api.\+explain\+\_\+handler = logging.\+Stream\+Handler()}

\Hypertarget{namespacecharset__normalizer_1_1api_a8e36221dc81c38e9f1e3b7ba080033dd}\index{charset\_normalizer.api@{charset\_normalizer.api}!logger@{logger}}
\index{logger@{logger}!charset\_normalizer.api@{charset\_normalizer.api}}
\doxysubsubsection{\texorpdfstring{logger}{logger}}
{\footnotesize\ttfamily \label{namespacecharset__normalizer_1_1api_a8e36221dc81c38e9f1e3b7ba080033dd} 
charset\+\_\+normalizer.\+api.\+logger = logging.\+get\+Logger("{}charset\+\_\+normalizer"{})}

