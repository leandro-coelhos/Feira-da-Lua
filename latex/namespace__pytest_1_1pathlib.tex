\doxysection{\+\_\+pytest.\+pathlib Namespace Reference}
\hypertarget{namespace__pytest_1_1pathlib}{}\label{namespace__pytest_1_1pathlib}\index{\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class__pytest_1_1pathlib_1_1_could_not_resolve_path_error}{Could\+Not\+Resolve\+Path\+Error}}
\item 
class \mbox{\hyperlink{class__pytest_1_1pathlib_1_1_import_mode}{Import\+Mode}}
\item 
class \mbox{\hyperlink{class__pytest_1_1pathlib_1_1_import_path_mismatch_error}{Import\+Path\+Mismatch\+Error}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_a49fb18e734de79bf93247d67a201673b}{\+\_\+ignore\+\_\+error}} (Exception exception)
\item 
\mbox{\hyperlink{namespace__pytest_1_1pathlib_a0eaa54319ebbb1846a29cd4ad31da4d4}{\+\_\+\+Any\+Pure\+Path}} \mbox{\hyperlink{namespace__pytest_1_1pathlib_a71cc9f2b91e8d7c2f31e80cc596fc1ad}{get\+\_\+lock\+\_\+path}} (\mbox{\hyperlink{namespace__pytest_1_1pathlib_a0eaa54319ebbb1846a29cd4ad31da4d4}{\+\_\+\+Any\+Pure\+Path}} path)
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_a230d9829caff4723397aee03ddadc7ae}{on\+\_\+rm\+\_\+rf\+\_\+error}} (Callable\mbox{[}..., Any\mbox{]}\texorpdfstring{$\vert$}{|}None func, str path, Base\+Exception\texorpdfstring{$\vert$}{|}tuple\mbox{[}type\mbox{[}Base\+Exception\mbox{]}, Base\+Exception, types.\+Traceback\+Type\texorpdfstring{$\vert$}{|}None\mbox{]} excinfo, \texorpdfstring{$\ast$}{*}, Path start\+\_\+path)
\item 
Path \mbox{\hyperlink{namespace__pytest_1_1pathlib_a6b8b0325e6efac0c038f9a724ab8a2bf}{ensure\+\_\+extended\+\_\+length\+\_\+path}} (Path path)
\item 
str \mbox{\hyperlink{namespace__pytest_1_1pathlib_ae544da450e5c7c6870a70be7cabc75d8}{get\+\_\+extended\+\_\+length\+\_\+path\+\_\+str}} (str path)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1pathlib_ae1f0c08537ab64dd461cfb6674625b38}{rm\+\_\+rf}} (Path path)
\item 
Iterator\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1pathlib_ab1843653a064d8dee4dcf9a5cc00679c}{find\+\_\+prefixed}} (Path root, str prefix)
\item 
Iterator\mbox{[}str\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1pathlib_a0addba70a654b247e36cb4401bc7dc12}{extract\+\_\+suffixes}} (Iterable\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]} iter, str prefix)
\item 
Iterator\mbox{[}str\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1pathlib_ae5a66215e40cad20f751eddc3c6e8721}{find\+\_\+suffixes}} (Path root, str prefix)
\item 
int \mbox{\hyperlink{namespace__pytest_1_1pathlib_aef6232b74550a186a8206597eefc3737}{parse\+\_\+num}} (str maybe\+\_\+num)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1pathlib_a2d36d17900127934577a8859d235bcfd}{\+\_\+force\+\_\+symlink}} (Path root, str\texorpdfstring{$\vert$}{|}Pure\+Path target, str\texorpdfstring{$\vert$}{|}Path link\+\_\+to)
\item 
Path \mbox{\hyperlink{namespace__pytest_1_1pathlib_a6ca62f92c9e61a349836eadf38245d85}{make\+\_\+numbered\+\_\+dir}} (Path root, str prefix, int mode=0o700)
\item 
Path \mbox{\hyperlink{namespace__pytest_1_1pathlib_a2fae1b99c0fbb9d314aceb95e668a401}{create\+\_\+cleanup\+\_\+lock}} (Path p)
\item 
Any \mbox{\hyperlink{namespace__pytest_1_1pathlib_a18e8d477b40f4178236b4e1a1465e550}{register\+\_\+cleanup\+\_\+lock\+\_\+removal}} (Path lock\+\_\+path, Any register=atexit.\+register)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1pathlib_a13e58fca02f174fa9bd72475840e51cc}{maybe\+\_\+delete\+\_\+a\+\_\+numbered\+\_\+dir}} (Path path)
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_a1c3f573b2bcd340dc200f85899715bfa}{ensure\+\_\+deletable}} (Path path, float consider\+\_\+lock\+\_\+dead\+\_\+if\+\_\+created\+\_\+before)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1pathlib_a94a716332cee4b0ffe6806ccfd56c390}{try\+\_\+cleanup}} (Path path, float consider\+\_\+lock\+\_\+dead\+\_\+if\+\_\+created\+\_\+before)
\item 
Iterator\mbox{[}Path\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1pathlib_ae357103ea4a06ecb2d8bd3b18af4ea53}{cleanup\+\_\+candidates}} (Path root, str prefix, int keep)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1pathlib_a029804adc1a9bf460f063bad46dade6a}{cleanup\+\_\+dead\+\_\+symlinks}} (Path root)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1pathlib_a9d1e52490b7f908dbc8b6041d0bba697}{cleanup\+\_\+numbered\+\_\+dir}} (Path root, str prefix, int keep, float consider\+\_\+lock\+\_\+dead\+\_\+if\+\_\+created\+\_\+before)
\item 
Path \mbox{\hyperlink{namespace__pytest_1_1pathlib_a31cda2f173f0946adac7122c00608b88}{make\+\_\+numbered\+\_\+dir\+\_\+with\+\_\+cleanup}} (Path root, str prefix, int keep, float lock\+\_\+timeout, int mode)
\item 
Path \mbox{\hyperlink{namespace__pytest_1_1pathlib_a16d692771185c792d8b0f888953061d9}{resolve\+\_\+from\+\_\+str}} (str input, Path rootpath)
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_a6b1004d7bebd54d347c235848846e2e8}{fnmatch\+\_\+ex}} (str pattern, str\texorpdfstring{$\vert$}{|}os.\+Path\+Like\mbox{[}str\mbox{]} path)
\item 
set\mbox{[}str\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1pathlib_afb98e10060724ec1d7bcffc434ee55d8}{parts}} (str s)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1pathlib_a96f2306195bc2afab763d5bd8c20ae9d}{symlink\+\_\+or\+\_\+skip}} (os.\+Path\+Like\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}str src, os.\+Path\+Like\mbox{[}str\mbox{]}\texorpdfstring{$\vert$}{|}str dst, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}Any kwargs)
\item 
Module\+Type \mbox{\hyperlink{namespace__pytest_1_1pathlib_adbc8e461599c3d27cc24516ee5565e13}{import\+\_\+path}} (str\texorpdfstring{$\vert$}{|}os.\+Path\+Like\mbox{[}str\mbox{]} path, \texorpdfstring{$\ast$}{*}, str\texorpdfstring{$\vert$}{|}\mbox{\hyperlink{class__pytest_1_1pathlib_1_1_import_mode}{Import\+Mode}} mode=\mbox{\hyperlink{class__pytest_1_1pathlib_1_1_import_mode_a3c8859503e2fee8e08c242b769efe1b8}{Import\+Mode.\+prepend}}, Path root, bool consider\+\_\+namespace\+\_\+packages)
\item 
Module\+Type\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespace__pytest_1_1pathlib_af158cc6a637b627de5fb10dc6d56dd53}{\+\_\+import\+\_\+module\+\_\+using\+\_\+spec}} (str module\+\_\+name, Path module\+\_\+path, Path module\+\_\+location, \texorpdfstring{$\ast$}{*}, bool insert\+\_\+modules)
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_a500b7dde594bf79fd876fcb912114d9f}{spec\+\_\+matches\+\_\+module\+\_\+path}} (Module\+Spec\texorpdfstring{$\vert$}{|}None module\+\_\+spec, Path module\+\_\+path)
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_a40b07abdf23e0fb0d65477da791e92ab}{\+\_\+is\+\_\+same}} (str f1, str f2)
\item 
str \mbox{\hyperlink{namespace__pytest_1_1pathlib_a627c18aa62422d2db2f1ad51382f5afd}{module\+\_\+name\+\_\+from\+\_\+path}} (Path path, Path root)
\item 
None \mbox{\hyperlink{namespace__pytest_1_1pathlib_acda9be6ad7371c8275fd7e08928726c5}{insert\+\_\+missing\+\_\+modules}} (dict\mbox{[}str, Module\+Type\mbox{]} modules, str module\+\_\+name)
\item 
Path\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespace__pytest_1_1pathlib_aca58c69dc664a8394910cb98591c2c3e}{resolve\+\_\+package\+\_\+path}} (Path path)
\item 
tuple\mbox{[}Path, str\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1pathlib_ae0d4d9c6518ac50dc96cac0b37d9ef7a}{resolve\+\_\+pkg\+\_\+root\+\_\+and\+\_\+module\+\_\+name}} (Path path, \texorpdfstring{$\ast$}{*}, bool consider\+\_\+namespace\+\_\+packages=False)
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_af40ce40c87f5e694865f40cbfa267f3c}{is\+\_\+importable}} (str module\+\_\+name, Path module\+\_\+path)
\item 
str\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespace__pytest_1_1pathlib_a95648f8e99507feb1f5978aaa70877f7}{compute\+\_\+module\+\_\+name}} (Path root, Path module\+\_\+path)
\item 
list\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1pathlib_a7902afd9185410d7886e257cfa28d6d0}{scandir}} (str\texorpdfstring{$\vert$}{|}os.\+Path\+Like\mbox{[}str\mbox{]} path, Callable\mbox{[}\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]}, object\mbox{]} sort\+\_\+key=lambda entry\+:entry.\+name)
\item 
Iterator\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]} \mbox{\hyperlink{namespace__pytest_1_1pathlib_a93c510d7d87a1bd007c78df762338f1e}{visit}} (str\texorpdfstring{$\vert$}{|}os.\+Path\+Like\mbox{[}str\mbox{]} path, Callable\mbox{[}\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]}, bool\mbox{]} recurse)
\item 
Path \mbox{\hyperlink{namespace__pytest_1_1pathlib_a3711f7c9b726c90c56e71a74a6644153}{absolutepath}} (str\texorpdfstring{$\vert$}{|}os.\+Path\+Like\mbox{[}str\mbox{]} path)
\item 
Path\texorpdfstring{$\vert$}{|}None \mbox{\hyperlink{namespace__pytest_1_1pathlib_a36570346e402c40e0ce5a83af6f33ab0}{commonpath}} (Path path1, Path path2)
\item 
str \mbox{\hyperlink{namespace__pytest_1_1pathlib_a551b7399b00c9a5673964d7a3e299f2f}{bestrelpath}} (Path directory, Path dest)
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_a477136b449c5773df097dd9410c8c3d1}{safe\+\_\+exists}} (Path p)
\item 
bool \mbox{\hyperlink{namespace__pytest_1_1pathlib_a92d7646f18c6cb5fe12117cf5f23701f}{samefile\+\_\+nofollow}} (Path p1, Path p2)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{namespace__pytest_1_1pathlib_a6c097e7a2732274f1e66f46e679d3fe2}{LOCK\+\_\+\+TIMEOUT}} = 60 \texorpdfstring{$\ast$}{*} 60 \texorpdfstring{$\ast$}{*} 24 \texorpdfstring{$\ast$}{*} 3
\item 
\mbox{\hyperlink{namespace__pytest_1_1pathlib_a0eaa54319ebbb1846a29cd4ad31da4d4}{\+\_\+\+Any\+Pure\+Path}} = Type\+Var("{}\+\_\+\+Any\+Pure\+Path"{}, bound=Pure\+Path)
\item 
tuple \mbox{\hyperlink{namespace__pytest_1_1pathlib_a4098dd7db7f37942e4d1e4898051a34d}{\+\_\+\+IGNORED\+\_\+\+ERRORS}} = (ENOENT, ENOTDIR, EBADF, ELOOP)
\item 
tuple \mbox{\hyperlink{namespace__pytest_1_1pathlib_a82dcc98dfd4f9e8e52ff548aaf17b6e8}{\+\_\+\+IGNORED\+\_\+\+WINERRORS}}
\end{DoxyCompactItemize}


\label{doc-func-members}
\Hypertarget{namespace__pytest_1_1pathlib_doc-func-members}
\doxysubsection{Function Documentation}
\Hypertarget{namespace__pytest_1_1pathlib_a2d36d17900127934577a8859d235bcfd}\index{\_pytest.pathlib@{\_pytest.pathlib}!\_force\_symlink@{\_force\_symlink}}
\index{\_force\_symlink@{\_force\_symlink}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{\_force\_symlink()}{\_force\_symlink()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a2d36d17900127934577a8859d235bcfd} 
 None \+\_\+pytest.\+pathlib.\+\_\+force\+\_\+symlink (\begin{DoxyParamCaption}\item[{Path}]{root}{, }\item[{str \texorpdfstring{$\vert$}{|} Pure\+Path}]{target}{, }\item[{str \texorpdfstring{$\vert$}{|} Path}]{link\+\_\+to}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Helper to create the current symlink.

It's full of race conditions that are reasonably OK to ignore
for the context of best effort linking to the latest test run.

The presumption being that in case of much parallelism
the inaccuracy is going to be acceptable.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a49fb18e734de79bf93247d67a201673b}\index{\_pytest.pathlib@{\_pytest.pathlib}!\_ignore\_error@{\_ignore\_error}}
\index{\_ignore\_error@{\_ignore\_error}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{\_ignore\_error()}{\_ignore\_error()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a49fb18e734de79bf93247d67a201673b} 
 bool \+\_\+pytest.\+pathlib.\+\_\+ignore\+\_\+error (\begin{DoxyParamCaption}\item[{Exception}]{exception}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespace__pytest_1_1pathlib_af158cc6a637b627de5fb10dc6d56dd53}\index{\_pytest.pathlib@{\_pytest.pathlib}!\_import\_module\_using\_spec@{\_import\_module\_using\_spec}}
\index{\_import\_module\_using\_spec@{\_import\_module\_using\_spec}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{\_import\_module\_using\_spec()}{\_import\_module\_using\_spec()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_af158cc6a637b627de5fb10dc6d56dd53} 
 Module\+Type \texorpdfstring{$\vert$}{|} None \+\_\+pytest.\+pathlib.\+\_\+import\+\_\+module\+\_\+using\+\_\+spec (\begin{DoxyParamCaption}\item[{str}]{module\+\_\+name}{, }\item[{Path}]{module\+\_\+path}{, }\item[{Path}]{module\+\_\+location}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{bool }]{insert\+\_\+modules}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Tries to import a module by its canonical name, path, and its parent location.

:param module_name:
    The expected module name, will become the key of `sys.modules`.

:param module_path:
    The file path of the module, for example `/foo/bar/test_demo.py`.
    If module is a package, pass the path to the  `__init__.py` of the package.
    If module is a namespace package, pass directory path.

:param module_location:
    The parent location of the module.
    If module is a package, pass the directory containing the `__init__.py` file.

:param insert_modules:
    If True, will call `insert_missing_modules` to create empty intermediate modules
    with made-up module names (when importing test files not reachable from `sys.path`).

Example 1 of parent_module_*:

    module_name:        "a.b.c.demo"
    module_path:        Path("a/b/c/demo.py")
    module_location:    Path("a/b/c/")
    if "a.b.c" is package ("a/b/c/__init__.py" exists), then
        parent_module_name:         "a.b.c"
        parent_module_path:         Path("a/b/c/__init__.py")
        parent_module_location:     Path("a/b/c/")
    else:
        parent_module_name:         "a.b.c"
        parent_module_path:         Path("a/b/c")
        parent_module_location:     Path("a/b/")

Example 2 of parent_module_*:

    module_name:        "a.b.c"
    module_path:        Path("a/b/c/__init__.py")
    module_location:    Path("a/b/c/")
    if  "a.b" is package ("a/b/__init__.py" exists), then
        parent_module_name:         "a.b"
        parent_module_path:         Path("a/b/__init__.py")
        parent_module_location:     Path("a/b/")
    else:
        parent_module_name:         "a.b"
        parent_module_path:         Path("a/b/")
        parent_module_location:     Path("a/")
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a40b07abdf23e0fb0d65477da791e92ab}\index{\_pytest.pathlib@{\_pytest.pathlib}!\_is\_same@{\_is\_same}}
\index{\_is\_same@{\_is\_same}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{\_is\_same()}{\_is\_same()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a40b07abdf23e0fb0d65477da791e92ab} 
bool \+\_\+pytest.\+pathlib.\+\_\+is\+\_\+same (\begin{DoxyParamCaption}\item[{str}]{f1}{, }\item[{str}]{f2}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespace__pytest_1_1pathlib_a3711f7c9b726c90c56e71a74a6644153}\index{\_pytest.pathlib@{\_pytest.pathlib}!absolutepath@{absolutepath}}
\index{absolutepath@{absolutepath}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{absolutepath()}{absolutepath()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a3711f7c9b726c90c56e71a74a6644153} 
 Path \+\_\+pytest.\+pathlib.\+absolutepath (\begin{DoxyParamCaption}\item[{str \texorpdfstring{$\vert$}{|} os.\+Path\+Like\mbox{[}str\mbox{]}}]{path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert a path to an absolute path using os.path.abspath.

Prefer this over Path.resolve() (see #6523).
Prefer this over Path.absolute() (not public, doesn't normalize).
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a551b7399b00c9a5673964d7a3e299f2f}\index{\_pytest.pathlib@{\_pytest.pathlib}!bestrelpath@{bestrelpath}}
\index{bestrelpath@{bestrelpath}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{bestrelpath()}{bestrelpath()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a551b7399b00c9a5673964d7a3e299f2f} 
 str \+\_\+pytest.\+pathlib.\+bestrelpath (\begin{DoxyParamCaption}\item[{Path}]{directory}{, }\item[{Path}]{dest}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a string which is a relative path from directory to dest such
that directory/bestrelpath == dest.

The paths must be either both absolute or both relative.

If no such path can be determined, returns dest.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_ae357103ea4a06ecb2d8bd3b18af4ea53}\index{\_pytest.pathlib@{\_pytest.pathlib}!cleanup\_candidates@{cleanup\_candidates}}
\index{cleanup\_candidates@{cleanup\_candidates}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{cleanup\_candidates()}{cleanup\_candidates()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_ae357103ea4a06ecb2d8bd3b18af4ea53} 
 Iterator\mbox{[}Path\mbox{]} \+\_\+pytest.\+pathlib.\+cleanup\+\_\+candidates (\begin{DoxyParamCaption}\item[{Path}]{root}{, }\item[{str}]{prefix}{, }\item[{int}]{keep}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}List candidates for numbered directories to be removed - follows py.path.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a029804adc1a9bf460f063bad46dade6a}\index{\_pytest.pathlib@{\_pytest.pathlib}!cleanup\_dead\_symlinks@{cleanup\_dead\_symlinks}}
\index{cleanup\_dead\_symlinks@{cleanup\_dead\_symlinks}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{cleanup\_dead\_symlinks()}{cleanup\_dead\_symlinks()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a029804adc1a9bf460f063bad46dade6a} 
 None \+\_\+pytest.\+pathlib.\+cleanup\+\_\+dead\+\_\+symlinks (\begin{DoxyParamCaption}\item[{Path}]{root}{}\end{DoxyParamCaption})}

\Hypertarget{namespace__pytest_1_1pathlib_a9d1e52490b7f908dbc8b6041d0bba697}\index{\_pytest.pathlib@{\_pytest.pathlib}!cleanup\_numbered\_dir@{cleanup\_numbered\_dir}}
\index{cleanup\_numbered\_dir@{cleanup\_numbered\_dir}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{cleanup\_numbered\_dir()}{cleanup\_numbered\_dir()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a9d1e52490b7f908dbc8b6041d0bba697} 
 None \+\_\+pytest.\+pathlib.\+cleanup\+\_\+numbered\+\_\+dir (\begin{DoxyParamCaption}\item[{Path}]{root}{, }\item[{str}]{prefix}{, }\item[{int}]{keep}{, }\item[{float }]{consider\+\_\+lock\+\_\+dead\+\_\+if\+\_\+created\+\_\+before}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Cleanup for lock driven numbered directories.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a36570346e402c40e0ce5a83af6f33ab0}\index{\_pytest.pathlib@{\_pytest.pathlib}!commonpath@{commonpath}}
\index{commonpath@{commonpath}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{commonpath()}{commonpath()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a36570346e402c40e0ce5a83af6f33ab0} 
 Path \texorpdfstring{$\vert$}{|} None \+\_\+pytest.\+pathlib.\+commonpath (\begin{DoxyParamCaption}\item[{Path}]{path1}{, }\item[{Path}]{path2}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the common part shared with the other path, or None if there is
no common part.

If one path is relative and one is absolute, returns None.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a95648f8e99507feb1f5978aaa70877f7}\index{\_pytest.pathlib@{\_pytest.pathlib}!compute\_module\_name@{compute\_module\_name}}
\index{compute\_module\_name@{compute\_module\_name}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{compute\_module\_name()}{compute\_module\_name()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a95648f8e99507feb1f5978aaa70877f7} 
 str \texorpdfstring{$\vert$}{|} None \+\_\+pytest.\+pathlib.\+compute\+\_\+module\+\_\+name (\begin{DoxyParamCaption}\item[{Path}]{root}{, }\item[{Path}]{module\+\_\+path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute a module name based on a path and a root anchor.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a2fae1b99c0fbb9d314aceb95e668a401}\index{\_pytest.pathlib@{\_pytest.pathlib}!create\_cleanup\_lock@{create\_cleanup\_lock}}
\index{create\_cleanup\_lock@{create\_cleanup\_lock}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{create\_cleanup\_lock()}{create\_cleanup\_lock()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a2fae1b99c0fbb9d314aceb95e668a401} 
 Path \+\_\+pytest.\+pathlib.\+create\+\_\+cleanup\+\_\+lock (\begin{DoxyParamCaption}\item[{Path}]{p}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Create a lock to prevent premature folder cleanup.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a1c3f573b2bcd340dc200f85899715bfa}\index{\_pytest.pathlib@{\_pytest.pathlib}!ensure\_deletable@{ensure\_deletable}}
\index{ensure\_deletable@{ensure\_deletable}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{ensure\_deletable()}{ensure\_deletable()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a1c3f573b2bcd340dc200f85899715bfa} 
 bool \+\_\+pytest.\+pathlib.\+ensure\+\_\+deletable (\begin{DoxyParamCaption}\item[{Path}]{path}{, }\item[{float}]{consider\+\_\+lock\+\_\+dead\+\_\+if\+\_\+created\+\_\+before}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Check if `path` is deletable based on whether the lock file is expired.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a6b8b0325e6efac0c038f9a724ab8a2bf}\index{\_pytest.pathlib@{\_pytest.pathlib}!ensure\_extended\_length\_path@{ensure\_extended\_length\_path}}
\index{ensure\_extended\_length\_path@{ensure\_extended\_length\_path}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{ensure\_extended\_length\_path()}{ensure\_extended\_length\_path()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a6b8b0325e6efac0c038f9a724ab8a2bf} 
 Path \+\_\+pytest.\+pathlib.\+ensure\+\_\+extended\+\_\+length\+\_\+path (\begin{DoxyParamCaption}\item[{Path}]{path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Get the extended-length version of a path (Windows).

On Windows, by default, the maximum length of a path (MAX_PATH) is 260
characters, and operations on paths longer than that fail. But it is possible
to overcome this by converting the path to "extended-length" form before
performing the operation:
https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation

On Windows, this function returns the extended-length absolute version of path.
On other platforms it returns path unchanged.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a0addba70a654b247e36cb4401bc7dc12}\index{\_pytest.pathlib@{\_pytest.pathlib}!extract\_suffixes@{extract\_suffixes}}
\index{extract\_suffixes@{extract\_suffixes}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{extract\_suffixes()}{extract\_suffixes()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a0addba70a654b247e36cb4401bc7dc12} 
 Iterator\mbox{[}str\mbox{]} \+\_\+pytest.\+pathlib.\+extract\+\_\+suffixes (\begin{DoxyParamCaption}\item[{Iterable\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]}}]{iter}{, }\item[{str}]{prefix}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the parts of the paths following the prefix.

:param iter: Iterator over path names.
:param prefix: Expected prefix of the path names.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_ab1843653a064d8dee4dcf9a5cc00679c}\index{\_pytest.pathlib@{\_pytest.pathlib}!find\_prefixed@{find\_prefixed}}
\index{find\_prefixed@{find\_prefixed}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{find\_prefixed()}{find\_prefixed()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_ab1843653a064d8dee4dcf9a5cc00679c} 
 Iterator\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]} \+\_\+pytest.\+pathlib.\+find\+\_\+prefixed (\begin{DoxyParamCaption}\item[{Path}]{root}{, }\item[{str}]{prefix}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Find all elements in root that begin with the prefix, case-insensitive.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_ae5a66215e40cad20f751eddc3c6e8721}\index{\_pytest.pathlib@{\_pytest.pathlib}!find\_suffixes@{find\_suffixes}}
\index{find\_suffixes@{find\_suffixes}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{find\_suffixes()}{find\_suffixes()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_ae5a66215e40cad20f751eddc3c6e8721} 
 Iterator\mbox{[}str\mbox{]} \+\_\+pytest.\+pathlib.\+find\+\_\+suffixes (\begin{DoxyParamCaption}\item[{Path}]{root}{, }\item[{str}]{prefix}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Combine find_prefixes and extract_suffixes.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a6b1004d7bebd54d347c235848846e2e8}\index{\_pytest.pathlib@{\_pytest.pathlib}!fnmatch\_ex@{fnmatch\_ex}}
\index{fnmatch\_ex@{fnmatch\_ex}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{fnmatch\_ex()}{fnmatch\_ex()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a6b1004d7bebd54d347c235848846e2e8} 
 bool \+\_\+pytest.\+pathlib.\+fnmatch\+\_\+ex (\begin{DoxyParamCaption}\item[{str}]{pattern}{, }\item[{str \texorpdfstring{$\vert$}{|} os.\+Path\+Like\mbox{[}str\mbox{]}}]{path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}A port of FNMatcher from py.path.common which works with PurePath() instances.

The difference between this algorithm and PurePath.match() is that the
latter matches "**" glob expressions for each part of the path, while
this algorithm uses the whole path instead.

For example:
    "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
    with this algorithm, but not with PurePath.match().

This algorithm was ported to keep backward-compatibility with existing
settings which assume paths match according this logic.

References:
* https://bugs.python.org/issue29249
* https://bugs.python.org/issue34731
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_ae544da450e5c7c6870a70be7cabc75d8}\index{\_pytest.pathlib@{\_pytest.pathlib}!get\_extended\_length\_path\_str@{get\_extended\_length\_path\_str}}
\index{get\_extended\_length\_path\_str@{get\_extended\_length\_path\_str}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{get\_extended\_length\_path\_str()}{get\_extended\_length\_path\_str()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_ae544da450e5c7c6870a70be7cabc75d8} 
 str \+\_\+pytest.\+pathlib.\+get\+\_\+extended\+\_\+length\+\_\+path\+\_\+str (\begin{DoxyParamCaption}\item[{str}]{path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert a path to a Windows extended length path.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a71cc9f2b91e8d7c2f31e80cc596fc1ad}\index{\_pytest.pathlib@{\_pytest.pathlib}!get\_lock\_path@{get\_lock\_path}}
\index{get\_lock\_path@{get\_lock\_path}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{get\_lock\_path()}{get\_lock\_path()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a71cc9f2b91e8d7c2f31e80cc596fc1ad} 
 \mbox{\hyperlink{namespace__pytest_1_1pathlib_a0eaa54319ebbb1846a29cd4ad31da4d4}{\+\_\+\+Any\+Pure\+Path}} \+\_\+pytest.\+pathlib.\+get\+\_\+lock\+\_\+path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace__pytest_1_1pathlib_a0eaa54319ebbb1846a29cd4ad31da4d4}{\+\_\+\+Any\+Pure\+Path}}}]{path}{}\end{DoxyParamCaption})}

\Hypertarget{namespace__pytest_1_1pathlib_adbc8e461599c3d27cc24516ee5565e13}\index{\_pytest.pathlib@{\_pytest.pathlib}!import\_path@{import\_path}}
\index{import\_path@{import\_path}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{import\_path()}{import\_path()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_adbc8e461599c3d27cc24516ee5565e13} 
 Module\+Type \+\_\+pytest.\+pathlib.\+import\+\_\+path (\begin{DoxyParamCaption}\item[{str \texorpdfstring{$\vert$}{|} os.\+Path\+Like\mbox{[}str\mbox{]}}]{path}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{str \texorpdfstring{$\vert$}{|} \mbox{\hyperlink{class__pytest_1_1pathlib_1_1_import_mode}{Import\+Mode}} }]{mode}{ = {\ttfamily \mbox{\hyperlink{class__pytest_1_1pathlib_1_1_import_mode_a3c8859503e2fee8e08c242b769efe1b8}{Import\+Mode.\+prepend}}}, }\item[{Path}]{root}{, }\item[{bool}]{consider\+\_\+namespace\+\_\+packages}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Import and return a module from the given path, which can be a file (a module) or
a directory (a package).

:param path:
    Path to the file to import.

:param mode:
    Controls the underlying import mechanism that will be used:

    * ImportMode.prepend: the directory containing the module (or package, taking
      `__init__.py` files into account) will be put at the *start* of `sys.path` before
      being imported with `importlib.import_module`.

    * ImportMode.append: same as `prepend`, but the directory will be appended
      to the end of `sys.path`, if not already in `sys.path`.

    * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`
      to import the module, which avoids having to muck with `sys.path` at all. It effectively
      allows having same-named test modules in different places.

:param root:
    Used as an anchor when mode == ImportMode.importlib to obtain
    a unique name for the module being imported so it can safely be stored
    into ``sys.modules``.

:param consider_namespace_packages:
    If True, consider namespace packages when resolving module names.

:raises ImportPathMismatchError:
    If after importing the given `path` and the module `__file__`
    are different. Only raised in `prepend` and `append` modes.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_acda9be6ad7371c8275fd7e08928726c5}\index{\_pytest.pathlib@{\_pytest.pathlib}!insert\_missing\_modules@{insert\_missing\_modules}}
\index{insert\_missing\_modules@{insert\_missing\_modules}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{insert\_missing\_modules()}{insert\_missing\_modules()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_acda9be6ad7371c8275fd7e08928726c5} 
 None \+\_\+pytest.\+pathlib.\+insert\+\_\+missing\+\_\+modules (\begin{DoxyParamCaption}\item[{dict\mbox{[}str, Module\+Type\mbox{]}}]{modules}{, }\item[{str}]{module\+\_\+name}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Used by ``import_path`` to create intermediate modules when using mode=importlib.

When we want to import a module as "src.tests.test_foo" for example, we need
to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
otherwise "src.tests.test_foo" is not importable by ``__import__``.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_af40ce40c87f5e694865f40cbfa267f3c}\index{\_pytest.pathlib@{\_pytest.pathlib}!is\_importable@{is\_importable}}
\index{is\_importable@{is\_importable}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{is\_importable()}{is\_importable()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_af40ce40c87f5e694865f40cbfa267f3c} 
 bool \+\_\+pytest.\+pathlib.\+is\+\_\+importable (\begin{DoxyParamCaption}\item[{str}]{module\+\_\+name}{, }\item[{Path}]{module\+\_\+path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return if the given module path could be imported normally by Python, akin to the user
entering the REPL and importing the corresponding module name directly, and corresponds
to the module_path specified.

:param module_name:
    Full module name that we want to check if is importable.
    For example, "app.models".

:param module_path:
    Full path to the python module/package we want to check if is importable.
    For example, "/projects/src/app/models.py".
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a6ca62f92c9e61a349836eadf38245d85}\index{\_pytest.pathlib@{\_pytest.pathlib}!make\_numbered\_dir@{make\_numbered\_dir}}
\index{make\_numbered\_dir@{make\_numbered\_dir}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{make\_numbered\_dir()}{make\_numbered\_dir()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a6ca62f92c9e61a349836eadf38245d85} 
 Path \+\_\+pytest.\+pathlib.\+make\+\_\+numbered\+\_\+dir (\begin{DoxyParamCaption}\item[{Path}]{root}{, }\item[{str}]{prefix}{, }\item[{int }]{mode}{ = {\ttfamily 0o700}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Create a directory with an increased number as suffix for the given prefix.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a31cda2f173f0946adac7122c00608b88}\index{\_pytest.pathlib@{\_pytest.pathlib}!make\_numbered\_dir\_with\_cleanup@{make\_numbered\_dir\_with\_cleanup}}
\index{make\_numbered\_dir\_with\_cleanup@{make\_numbered\_dir\_with\_cleanup}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{make\_numbered\_dir\_with\_cleanup()}{make\_numbered\_dir\_with\_cleanup()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a31cda2f173f0946adac7122c00608b88} 
 Path \+\_\+pytest.\+pathlib.\+make\+\_\+numbered\+\_\+dir\+\_\+with\+\_\+cleanup (\begin{DoxyParamCaption}\item[{Path}]{root}{, }\item[{str}]{prefix}{, }\item[{int}]{keep}{, }\item[{float}]{lock\+\_\+timeout}{, }\item[{int}]{mode}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Create a numbered dir with a cleanup lock and remove old ones.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a13e58fca02f174fa9bd72475840e51cc}\index{\_pytest.pathlib@{\_pytest.pathlib}!maybe\_delete\_a\_numbered\_dir@{maybe\_delete\_a\_numbered\_dir}}
\index{maybe\_delete\_a\_numbered\_dir@{maybe\_delete\_a\_numbered\_dir}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{maybe\_delete\_a\_numbered\_dir()}{maybe\_delete\_a\_numbered\_dir()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a13e58fca02f174fa9bd72475840e51cc} 
 None \+\_\+pytest.\+pathlib.\+maybe\+\_\+delete\+\_\+a\+\_\+numbered\+\_\+dir (\begin{DoxyParamCaption}\item[{Path}]{path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Remove a numbered directory if its lock can be obtained and it does
not seem to be in use.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a627c18aa62422d2db2f1ad51382f5afd}\index{\_pytest.pathlib@{\_pytest.pathlib}!module\_name\_from\_path@{module\_name\_from\_path}}
\index{module\_name\_from\_path@{module\_name\_from\_path}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{module\_name\_from\_path()}{module\_name\_from\_path()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a627c18aa62422d2db2f1ad51382f5afd} 
 str \+\_\+pytest.\+pathlib.\+module\+\_\+name\+\_\+from\+\_\+path (\begin{DoxyParamCaption}\item[{Path}]{path}{, }\item[{Path}]{root}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a dotted module name based on the given path, anchored on root.

For example: path="projects/src/tests/test_foo.py" and root="/projects", the
resulting module name will be "src.tests.test_foo".
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a230d9829caff4723397aee03ddadc7ae}\index{\_pytest.pathlib@{\_pytest.pathlib}!on\_rm\_rf\_error@{on\_rm\_rf\_error}}
\index{on\_rm\_rf\_error@{on\_rm\_rf\_error}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{on\_rm\_rf\_error()}{on\_rm\_rf\_error()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a230d9829caff4723397aee03ddadc7ae} 
 bool \+\_\+pytest.\+pathlib.\+on\+\_\+rm\+\_\+rf\+\_\+error (\begin{DoxyParamCaption}\item[{Callable\mbox{[}..., Any\mbox{]} \texorpdfstring{$\vert$}{|} None}]{func}{, }\item[{str}]{path}{, }\item[{Base\+Exception     \texorpdfstring{$\vert$}{|} tuple\mbox{[}type\mbox{[}Base\+Exception\mbox{]}, Base\+Exception, types.\+Traceback\+Type \texorpdfstring{$\vert$}{|} None\mbox{]}}]{excinfo}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{Path}]{start\+\_\+path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Handle known read-only errors during rmtree.

The returned value is used only by our own tests.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_aef6232b74550a186a8206597eefc3737}\index{\_pytest.pathlib@{\_pytest.pathlib}!parse\_num@{parse\_num}}
\index{parse\_num@{parse\_num}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{parse\_num()}{parse\_num()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_aef6232b74550a186a8206597eefc3737} 
 int \+\_\+pytest.\+pathlib.\+parse\+\_\+num (\begin{DoxyParamCaption}\item[{str}]{maybe\+\_\+num}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Parse number path suffixes, returns -1 on error.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_afb98e10060724ec1d7bcffc434ee55d8}\index{\_pytest.pathlib@{\_pytest.pathlib}!parts@{parts}}
\index{parts@{parts}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{parts()}{parts()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_afb98e10060724ec1d7bcffc434ee55d8} 
 set\mbox{[}str\mbox{]} \+\_\+pytest.\+pathlib.\+parts (\begin{DoxyParamCaption}\item[{str}]{s}{}\end{DoxyParamCaption})}

\Hypertarget{namespace__pytest_1_1pathlib_a18e8d477b40f4178236b4e1a1465e550}\index{\_pytest.pathlib@{\_pytest.pathlib}!register\_cleanup\_lock\_removal@{register\_cleanup\_lock\_removal}}
\index{register\_cleanup\_lock\_removal@{register\_cleanup\_lock\_removal}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{register\_cleanup\_lock\_removal()}{register\_cleanup\_lock\_removal()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a18e8d477b40f4178236b4e1a1465e550} 
 Any \+\_\+pytest.\+pathlib.\+register\+\_\+cleanup\+\_\+lock\+\_\+removal (\begin{DoxyParamCaption}\item[{Path}]{lock\+\_\+path}{, }\item[{Any }]{register}{ = {\ttfamily atexit.register}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Register a cleanup function for removing a lock, by default on atexit.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a16d692771185c792d8b0f888953061d9}\index{\_pytest.pathlib@{\_pytest.pathlib}!resolve\_from\_str@{resolve\_from\_str}}
\index{resolve\_from\_str@{resolve\_from\_str}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{resolve\_from\_str()}{resolve\_from\_str()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a16d692771185c792d8b0f888953061d9} 
 Path \+\_\+pytest.\+pathlib.\+resolve\+\_\+from\+\_\+str (\begin{DoxyParamCaption}\item[{str}]{input}{, }\item[{Path}]{rootpath}{}\end{DoxyParamCaption})}

\Hypertarget{namespace__pytest_1_1pathlib_aca58c69dc664a8394910cb98591c2c3e}\index{\_pytest.pathlib@{\_pytest.pathlib}!resolve\_package\_path@{resolve\_package\_path}}
\index{resolve\_package\_path@{resolve\_package\_path}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{resolve\_package\_path()}{resolve\_package\_path()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_aca58c69dc664a8394910cb98591c2c3e} 
 Path \texorpdfstring{$\vert$}{|} None \+\_\+pytest.\+pathlib.\+resolve\+\_\+package\+\_\+path (\begin{DoxyParamCaption}\item[{Path}]{path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the Python package path by looking for the last
directory upwards which still contains an __init__.py.

Returns None if it cannot be determined.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_ae0d4d9c6518ac50dc96cac0b37d9ef7a}\index{\_pytest.pathlib@{\_pytest.pathlib}!resolve\_pkg\_root\_and\_module\_name@{resolve\_pkg\_root\_and\_module\_name}}
\index{resolve\_pkg\_root\_and\_module\_name@{resolve\_pkg\_root\_and\_module\_name}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{resolve\_pkg\_root\_and\_module\_name()}{resolve\_pkg\_root\_and\_module\_name()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_ae0d4d9c6518ac50dc96cac0b37d9ef7a} 
 tuple\mbox{[}Path, str\mbox{]} \+\_\+pytest.\+pathlib.\+resolve\+\_\+pkg\+\_\+root\+\_\+and\+\_\+module\+\_\+name (\begin{DoxyParamCaption}\item[{Path}]{path}{, }\item[{\texorpdfstring{$\ast$}{*}}]{}{, }\item[{bool }]{consider\+\_\+namespace\+\_\+packages}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the path to the directory of the root package that contains the
given Python file, and its module name:

    src/
        app/
            __init__.py
            core/
                __init__.py
                models.py

Passing the full path to `models.py` will yield Path("src") and "app.core.models".

If consider_namespace_packages is True, then we additionally check upwards in the hierarchy
for namespace packages:

https://packaging.python.org/en/latest/guides/packaging-namespace-packages

Raises CouldNotResolvePathError if the given path does not belong to a package (missing any __init__.py files).
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_ae1f0c08537ab64dd461cfb6674625b38}\index{\_pytest.pathlib@{\_pytest.pathlib}!rm\_rf@{rm\_rf}}
\index{rm\_rf@{rm\_rf}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{rm\_rf()}{rm\_rf()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_ae1f0c08537ab64dd461cfb6674625b38} 
 None \+\_\+pytest.\+pathlib.\+rm\+\_\+rf (\begin{DoxyParamCaption}\item[{Path}]{path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Remove the path contents recursively, even if some elements
are read-only.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a477136b449c5773df097dd9410c8c3d1}\index{\_pytest.pathlib@{\_pytest.pathlib}!safe\_exists@{safe\_exists}}
\index{safe\_exists@{safe\_exists}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{safe\_exists()}{safe\_exists()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a477136b449c5773df097dd9410c8c3d1} 
 bool \+\_\+pytest.\+pathlib.\+safe\+\_\+exists (\begin{DoxyParamCaption}\item[{Path}]{p}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Like Path.exists(), but account for input arguments that might be too long (#11394).\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a92d7646f18c6cb5fe12117cf5f23701f}\index{\_pytest.pathlib@{\_pytest.pathlib}!samefile\_nofollow@{samefile\_nofollow}}
\index{samefile\_nofollow@{samefile\_nofollow}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{samefile\_nofollow()}{samefile\_nofollow()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a92d7646f18c6cb5fe12117cf5f23701f} 
 bool \+\_\+pytest.\+pathlib.\+samefile\+\_\+nofollow (\begin{DoxyParamCaption}\item[{Path}]{p1}{, }\item[{Path}]{p2}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Test whether two paths reference the same actual file or directory.

Unlike Path.samefile(), does not resolve symlinks.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a7902afd9185410d7886e257cfa28d6d0}\index{\_pytest.pathlib@{\_pytest.pathlib}!scandir@{scandir}}
\index{scandir@{scandir}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{scandir()}{scandir()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a7902afd9185410d7886e257cfa28d6d0} 
 list\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]} \+\_\+pytest.\+pathlib.\+scandir (\begin{DoxyParamCaption}\item[{str \texorpdfstring{$\vert$}{|} os.\+Path\+Like\mbox{[}str\mbox{]}}]{path}{, }\item[{Callable\mbox{[}\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]}, object\mbox{]} }]{sort\+\_\+key}{ = {\ttfamily lambda~entry\+:~entry.name}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Scan a directory recursively, in breadth-first order.

The returned entries are sorted according to the given key.
The default is to sort by name.
If the directory does not exist, return an empty list.
\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a500b7dde594bf79fd876fcb912114d9f}\index{\_pytest.pathlib@{\_pytest.pathlib}!spec\_matches\_module\_path@{spec\_matches\_module\_path}}
\index{spec\_matches\_module\_path@{spec\_matches\_module\_path}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{spec\_matches\_module\_path()}{spec\_matches\_module\_path()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a500b7dde594bf79fd876fcb912114d9f} 
 bool \+\_\+pytest.\+pathlib.\+spec\+\_\+matches\+\_\+module\+\_\+path (\begin{DoxyParamCaption}\item[{Module\+Spec \texorpdfstring{$\vert$}{|} None}]{module\+\_\+spec}{, }\item[{Path}]{module\+\_\+path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return true if the given ModuleSpec can be used to import the given module path.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a96f2306195bc2afab763d5bd8c20ae9d}\index{\_pytest.pathlib@{\_pytest.pathlib}!symlink\_or\_skip@{symlink\_or\_skip}}
\index{symlink\_or\_skip@{symlink\_or\_skip}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{symlink\_or\_skip()}{symlink\_or\_skip()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a96f2306195bc2afab763d5bd8c20ae9d} 
 None \+\_\+pytest.\+pathlib.\+symlink\+\_\+or\+\_\+skip (\begin{DoxyParamCaption}\item[{os.\+Path\+Like\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} str}]{src}{, }\item[{os.\+Path\+Like\mbox{[}str\mbox{]} \texorpdfstring{$\vert$}{|} str}]{dst}{, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}Any}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Make a symlink, or skip the test in case symlinks are not supported.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a94a716332cee4b0ffe6806ccfd56c390}\index{\_pytest.pathlib@{\_pytest.pathlib}!try\_cleanup@{try\_cleanup}}
\index{try\_cleanup@{try\_cleanup}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{try\_cleanup()}{try\_cleanup()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a94a716332cee4b0ffe6806ccfd56c390} 
 None \+\_\+pytest.\+pathlib.\+try\+\_\+cleanup (\begin{DoxyParamCaption}\item[{Path}]{path}{, }\item[{float}]{consider\+\_\+lock\+\_\+dead\+\_\+if\+\_\+created\+\_\+before}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Try to cleanup a folder if we can ensure it's deletable.\end{DoxyVerb}
 \Hypertarget{namespace__pytest_1_1pathlib_a93c510d7d87a1bd007c78df762338f1e}\index{\_pytest.pathlib@{\_pytest.pathlib}!visit@{visit}}
\index{visit@{visit}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{visit()}{visit()}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a93c510d7d87a1bd007c78df762338f1e} 
 Iterator\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]} \+\_\+pytest.\+pathlib.\+visit (\begin{DoxyParamCaption}\item[{str \texorpdfstring{$\vert$}{|} os.\+Path\+Like\mbox{[}str\mbox{]}}]{path}{, }\item[{Callable\mbox{[}\mbox{[}os.\+Dir\+Entry\mbox{[}str\mbox{]}\mbox{]}, bool\mbox{]} }]{recurse}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Walk a directory recursively, in breadth-first order.

The `recurse` predicate determines whether a directory is recursed.

Entries at each directory level are sorted.
\end{DoxyVerb}
 

\label{doc-var-members}
\Hypertarget{namespace__pytest_1_1pathlib_doc-var-members}
\doxysubsection{Variable Documentation}
\Hypertarget{namespace__pytest_1_1pathlib_a0eaa54319ebbb1846a29cd4ad31da4d4}\index{\_pytest.pathlib@{\_pytest.pathlib}!\_AnyPurePath@{\_AnyPurePath}}
\index{\_AnyPurePath@{\_AnyPurePath}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{\_AnyPurePath}{\_AnyPurePath}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a0eaa54319ebbb1846a29cd4ad31da4d4} 
\+\_\+pytest.\+pathlib.\+\_\+\+Any\+Pure\+Path = Type\+Var("{}\+\_\+\+Any\+Pure\+Path"{}, bound=Pure\+Path)\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespace__pytest_1_1pathlib_a4098dd7db7f37942e4d1e4898051a34d}\index{\_pytest.pathlib@{\_pytest.pathlib}!\_IGNORED\_ERRORS@{\_IGNORED\_ERRORS}}
\index{\_IGNORED\_ERRORS@{\_IGNORED\_ERRORS}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{\_IGNORED\_ERRORS}{\_IGNORED\_ERRORS}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a4098dd7db7f37942e4d1e4898051a34d} 
tuple \+\_\+pytest.\+pathlib.\+\_\+\+IGNORED\+\_\+\+ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)\hspace{0.3cm}{\ttfamily [protected]}}

\Hypertarget{namespace__pytest_1_1pathlib_a82dcc98dfd4f9e8e52ff548aaf17b6e8}\index{\_pytest.pathlib@{\_pytest.pathlib}!\_IGNORED\_WINERRORS@{\_IGNORED\_WINERRORS}}
\index{\_IGNORED\_WINERRORS@{\_IGNORED\_WINERRORS}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{\_IGNORED\_WINERRORS}{\_IGNORED\_WINERRORS}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a82dcc98dfd4f9e8e52ff548aaf17b6e8} 
tuple \+\_\+pytest.\+pathlib.\+\_\+\+IGNORED\+\_\+\+WINERRORS\hspace{0.3cm}{\ttfamily [protected]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ (}
\DoxyCodeLine{00002\ \ \ \ \ 21,\ \ \textcolor{comment}{\#\ ERROR\_NOT\_READY\ -\/\ drive\ exists\ but\ is\ not\ accessible}}
\DoxyCodeLine{00003\ \ \ \ \ 1921,\ \ \textcolor{comment}{\#\ ERROR\_CANT\_RESOLVE\_FILENAME\ -\/\ fix\ for\ broken\ symlink\ pointing\ to\ itself}}
\DoxyCodeLine{00004\ )}

\end{DoxyCode}
\Hypertarget{namespace__pytest_1_1pathlib_a6c097e7a2732274f1e66f46e679d3fe2}\index{\_pytest.pathlib@{\_pytest.pathlib}!LOCK\_TIMEOUT@{LOCK\_TIMEOUT}}
\index{LOCK\_TIMEOUT@{LOCK\_TIMEOUT}!\_pytest.pathlib@{\_pytest.pathlib}}
\doxysubsubsection{\texorpdfstring{LOCK\_TIMEOUT}{LOCK\_TIMEOUT}}
{\footnotesize\ttfamily \label{namespace__pytest_1_1pathlib_a6c097e7a2732274f1e66f46e679d3fe2} 
int \+\_\+pytest.\+pathlib.\+LOCK\+\_\+\+TIMEOUT = 60 \texorpdfstring{$\ast$}{*} 60 \texorpdfstring{$\ast$}{*} 24 \texorpdfstring{$\ast$}{*} 3}

