<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: attr._funcs Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceattr_1_1__funcs.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">attr._funcs Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ea4558a56652f9f52210b5b304cdb69" id="r_a9ea4558a56652f9f52210b5b304cdb69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea4558a56652f9f52210b5b304cdb69">asdict</a> (inst, recurse=True, filter=None, dict_factory=dict, retain_collection_types=False, value_serializer=None)</td></tr>
<tr class="memitem:ae751cfcf1cd40edc983e226c2442b142" id="r_ae751cfcf1cd40edc983e226c2442b142"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae751cfcf1cd40edc983e226c2442b142">_asdict_anything</a> (val, is_key, filter, dict_factory, retain_collection_types, value_serializer)</td></tr>
<tr class="memitem:aa56e821cedf493375f974ff06750158f" id="r_aa56e821cedf493375f974ff06750158f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa56e821cedf493375f974ff06750158f">astuple</a> (inst, recurse=True, filter=None, tuple_factory=tuple, retain_collection_types=False)</td></tr>
<tr class="memitem:acb41daebc62d8bfd9197c816a81b1cce" id="r_acb41daebc62d8bfd9197c816a81b1cce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb41daebc62d8bfd9197c816a81b1cce">has</a> (cls)</td></tr>
<tr class="memitem:af582f4beeebbbc97570a5768fa894483" id="r_af582f4beeebbbc97570a5768fa894483"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af582f4beeebbbc97570a5768fa894483">assoc</a> (inst, **changes)</td></tr>
<tr class="memitem:aa25d35711ece45152c950373bb03e9cb" id="r_aa25d35711ece45152c950373bb03e9cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa25d35711ece45152c950373bb03e9cb">resolve_types</a> (cls, globalns=None, localns=None, attribs=None, include_extras=True)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1a32def4c99e841ddec97fc1cfc1246d" id="r_a1a32def4c99e841ddec97fc1cfc1246d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a32def4c99e841ddec97fc1cfc1246d">_ATOMIC_TYPES</a></td></tr>
<tr class="memitem:ac6a492efb7e26ca6a5892be6270b0fa8" id="r_ac6a492efb7e26ca6a5892be6270b0fa8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6a492efb7e26ca6a5892be6270b0fa8">__attrs_attrs__</a> = generic_attrs</td></tr>
<tr class="memitem:aaf7ced476ccc42749cee85a9db9122ea" id="r_aaf7ced476ccc42749cee85a9db9122ea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf7ced476ccc42749cee85a9db9122ea">__attrs_types_resolved__</a> = cls</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ae751cfcf1cd40edc983e226c2442b142" name="ae751cfcf1cd40edc983e226c2442b142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae751cfcf1cd40edc983e226c2442b142">&#9670;&#160;</a></span>_asdict_anything()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs._asdict_anything </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>is_key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dict_factory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>retain_collection_types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>value_serializer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">``asdict`` only works on attrs instances, this works on anything.
</pre> 
</div>
</div>
<a id="a9ea4558a56652f9f52210b5b304cdb69" name="a9ea4558a56652f9f52210b5b304cdb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea4558a56652f9f52210b5b304cdb69">&#9670;&#160;</a></span>asdict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.asdict </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>recurse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dict_factory</em></span><span class="paramdefsep"> = </span><span class="paramdefval">dict</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>retain_collection_types</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>value_serializer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the *attrs* attribute values of *inst* as a dict.

Optionally recurse into other *attrs*-decorated classes.

Args:
    inst: Instance of an *attrs*-decorated class.

    recurse (bool): Recurse into classes that are also *attrs*-decorated.

    filter (~typing.Callable):
        A callable whose return code determines whether an attribute or
        element is included (`True`) or dropped (`False`).  Is called with
        the `attrs.Attribute` as the first argument and the value as the
        second argument.

    dict_factory (~typing.Callable):
        A callable to produce dictionaries from.  For example, to produce
        ordered dictionaries instead of normal Python dictionaries, pass in
        ``collections.OrderedDict``.

    retain_collection_types (bool):
        Do not convert to `list` when encountering an attribute whose type
        is `tuple` or `set`.  Only meaningful if *recurse* is `True`.

    value_serializer (typing.Callable | None):
        A hook that is called for every attribute or dict key/value.  It
        receives the current instance, field and value and must return the
        (updated) value.  The hook is run *after* the optional *filter* has
        been applied.

Returns:
    Return type of *dict_factory*.

Raises:
    attrs.exceptions.NotAnAttrsClassError:
        If *cls* is not an *attrs* class.

..  versionadded:: 16.0.0 *dict_factory*
..  versionadded:: 16.1.0 *retain_collection_types*
..  versionadded:: 20.3.0 *value_serializer*
..  versionadded:: 21.3.0
    If a dict has a collection for a key, it is serialized as a tuple.
</pre> 
</div>
</div>
<a id="af582f4beeebbbc97570a5768fa894483" name="af582f4beeebbbc97570a5768fa894483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af582f4beeebbbc97570a5768fa894483">&#9670;&#160;</a></span>assoc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.assoc </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**</td>          <td class="paramname"><span class="paramname"><em>changes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Copy *inst* and apply *changes*.

This is different from `evolve` that applies the changes to the arguments
that create the new instance.

`evolve`'s behavior is preferable, but there are `edge cases`_ where it
doesn't work. Therefore `assoc` is deprecated, but will not be removed.

.. _`edge cases`: https://github.com/python-attrs/attrs/issues/251

Args:
    inst: Instance of a class with *attrs* attributes.

    changes: Keyword changes in the new copy.

Returns:
    A copy of inst with *changes* incorporated.

Raises:
    attrs.exceptions.AttrsAttributeNotFoundError:
        If *attr_name* couldn't be found on *cls*.

    attrs.exceptions.NotAnAttrsClassError:
        If *cls* is not an *attrs* class.

..  deprecated:: 17.1.0
    Use `attrs.evolve` instead if you can. This function will not be
    removed du to the slightly different approach compared to
    `attrs.evolve`, though.
</pre> 
</div>
</div>
<a id="aa56e821cedf493375f974ff06750158f" name="aa56e821cedf493375f974ff06750158f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56e821cedf493375f974ff06750158f">&#9670;&#160;</a></span>astuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.astuple </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>inst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>recurse</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>tuple_factory</em></span><span class="paramdefsep"> = </span><span class="paramdefval">tuple</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>retain_collection_types</em></span><span class="paramdefsep"> = </span><span class="paramdefval">False</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the *attrs* attribute values of *inst* as a tuple.

Optionally recurse into other *attrs*-decorated classes.

Args:
    inst: Instance of an *attrs*-decorated class.

    recurse (bool):
        Recurse into classes that are also *attrs*-decorated.

    filter (~typing.Callable):
        A callable whose return code determines whether an attribute or
        element is included (`True`) or dropped (`False`).  Is called with
        the `attrs.Attribute` as the first argument and the value as the
        second argument.

    tuple_factory (~typing.Callable):
        A callable to produce tuples from. For example, to produce lists
        instead of tuples.

    retain_collection_types (bool):
        Do not convert to `list` or `dict` when encountering an attribute
        which type is `tuple`, `dict` or `set`. Only meaningful if
        *recurse* is `True`.

Returns:
    Return type of *tuple_factory*

Raises:
    attrs.exceptions.NotAnAttrsClassError:
        If *cls* is not an *attrs* class.

..  versionadded:: 16.2.0
</pre> 
</div>
</div>
<a id="acb41daebc62d8bfd9197c816a81b1cce" name="acb41daebc62d8bfd9197c816a81b1cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb41daebc62d8bfd9197c816a81b1cce">&#9670;&#160;</a></span>has()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.has </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cls</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check whether *cls* is a class with *attrs* attributes.

Args:
    cls (type): Class to introspect.

Raises:
    TypeError: If *cls* is not a class.

Returns:
    bool:
</pre> 
</div>
</div>
<a id="aa25d35711ece45152c950373bb03e9cb" name="aa25d35711ece45152c950373bb03e9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25d35711ece45152c950373bb03e9cb">&#9670;&#160;</a></span>resolve_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.resolve_types </td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>globalns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>localns</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>attribs</em></span><span class="paramdefsep"> = </span><span class="paramdefval">None</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>include_extras</em></span><span class="paramdefsep"> = </span><span class="paramdefval">True</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Resolve any strings and forward annotations in type annotations.

This is only required if you need concrete types in :class:`Attribute`'s
*type* field. In other words, you don't need to resolve your types if you
only use them for static type checking.

With no arguments, names will be looked up in the module in which the class
was created. If this is not what you want, for example, if the name only
exists inside a method, you may pass *globalns* or *localns* to specify
other dictionaries in which to look up these names. See the docs of
`typing.get_type_hints` for more details.

Args:
    cls (type): Class to resolve.

    globalns (dict | None): Dictionary containing global variables.

    localns (dict | None): Dictionary containing local variables.

    attribs (list | None):
        List of attribs for the given class. This is necessary when calling
        from inside a ``field_transformer`` since *cls* is not an *attrs*
        class yet.

    include_extras (bool):
        Resolve more accurately, if possible. Pass ``include_extras`` to
        ``typing.get_hints``, if supported by the typing module. On
        supported Python versions (3.9+), this resolves the types more
        accurately.

Raises:
    TypeError: If *cls* is not a class.

    attrs.exceptions.NotAnAttrsClassError:
        If *cls* is not an *attrs* class and you didn't pass any attribs.

    NameError: If types cannot be resolved because of missing variables.

Returns:
    *cls* so you can use this function also as a class decorator. Please
    note that you have to apply it **after** `attrs.define`. That means the
    decorator has to come in the line **before** `attrs.define`.

..  versionadded:: 20.1.0
..  versionadded:: 21.1.0 *attribs*
..  versionadded:: 23.1.0 *include_extras*
</pre> 
</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ac6a492efb7e26ca6a5892be6270b0fa8" name="ac6a492efb7e26ca6a5892be6270b0fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a492efb7e26ca6a5892be6270b0fa8">&#9670;&#160;</a></span>__attrs_attrs__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.__attrs_attrs__ = generic_attrs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf7ced476ccc42749cee85a9db9122ea" name="aaf7ced476ccc42749cee85a9db9122ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7ced476ccc42749cee85a9db9122ea">&#9670;&#160;</a></span>__attrs_types_resolved__</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs.__attrs_types_resolved__ = cls</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a32def4c99e841ddec97fc1cfc1246d" name="a1a32def4c99e841ddec97fc1cfc1246d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a32def4c99e841ddec97fc1cfc1246d">&#9670;&#160;</a></span>_ATOMIC_TYPES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">attr._funcs._ATOMIC_TYPES</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  frozenset(</div>
<div class="line"><span class="lineno">    2</span>    {</div>
<div class="line"><span class="lineno">    3</span>        type(<span class="keywordtype">None</span>),</div>
<div class="line"><span class="lineno">    4</span>        bool,</div>
<div class="line"><span class="lineno">    5</span>        int,</div>
<div class="line"><span class="lineno">    6</span>        float,</div>
<div class="line"><span class="lineno">    7</span>        str,</div>
<div class="line"><span class="lineno">    8</span>        complex,</div>
<div class="line"><span class="lineno">    9</span>        bytes,</div>
<div class="line"><span class="lineno">   10</span>        type(...),</div>
<div class="line"><span class="lineno">   11</span>        type,</div>
<div class="line"><span class="lineno">   12</span>        range,</div>
<div class="line"><span class="lineno">   13</span>        property,</div>
<div class="line"><span class="lineno">   14</span>    }</div>
<div class="line"><span class="lineno">   15</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceattr.html">attr</a></li><li class="navelem"><a href="namespaceattr_1_1__funcs.html">_funcs</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
